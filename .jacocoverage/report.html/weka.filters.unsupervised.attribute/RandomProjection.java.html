<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>RandomProjection.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCoverage analysis of project &quot;Weka-3.6.10&quot; (powered by JaCoCo from EclEmma)</a> &gt; <a href="index.source.html" class="el_package">weka.filters.unsupervised.attribute</a> &gt; <span class="el_source">RandomProjection.java</span></div><h1>RandomProjection.java</h1><pre class="source lang-java linenums">/*
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation; either version 2 of the License, or
 *    (at your option) any later version.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not, write to the Free Software
 *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/*
 *    RandomProjection.java
 *    Copyright (C) 2003 University of Waikato, Hamilton, New Zealand
 *
 */

package weka.filters.unsupervised.attribute;

import weka.core.Attribute;
import weka.core.Capabilities;
import weka.core.FastVector;
import weka.core.Instance;
import weka.core.Instances;
import weka.core.Option;
import weka.core.OptionHandler;
import weka.core.RevisionUtils;
import weka.core.SelectedTag;
import weka.core.Tag;
import weka.core.TechnicalInformation;
import weka.core.TechnicalInformationHandler;
import weka.core.Utils;
import weka.core.Capabilities.Capability;
import weka.core.TechnicalInformation.Field;
import weka.core.TechnicalInformation.Type;
import weka.filters.Filter;
import weka.filters.UnsupervisedFilter;

import java.util.Enumeration;
import java.util.Random;
import java.util.Vector;

/** 
 &lt;!-- globalinfo-start --&gt;
 * Reduces the dimensionality of the data by projecting it onto a lower dimensional subspace using a random matrix with columns of unit length (i.e. It will reduce the number of attributes in the data while preserving much of its variation like PCA, but at a much less computational cost).&lt;br/&gt;
 * It first applies the  NominalToBinary filter to convert all attributes to numeric before reducing the dimension. It preserves the class attribute.&lt;br/&gt;
 * &lt;br/&gt;
 * For more information, see:&lt;br/&gt;
 * &lt;br/&gt;
 * Dmitriy Fradkin, David Madigan: Experiments with random projections for machine learning. In: KDD '03: Proceedings of the ninth ACM SIGKDD international conference on Knowledge discovery and data mining, New York, NY, USA, 517-522, 003.
 * &lt;p/&gt;
 &lt;!-- globalinfo-end --&gt;
 * 
 &lt;!-- technical-bibtex-start --&gt;
 * BibTeX:
 * &lt;pre&gt;
 * &amp;#64;inproceedings{Fradkin003,
 *    address = {New York, NY, USA},
 *    author = {Dmitriy Fradkin and David Madigan},
 *    booktitle = {KDD '03: Proceedings of the ninth ACM SIGKDD international conference on Knowledge discovery and data mining},
 *    pages = {517-522},
 *    publisher = {ACM Press},
 *    title = {Experiments with random projections for machine learning},
 *    year = {003}
 * }
 * &lt;/pre&gt;
 * &lt;p/&gt;
 &lt;!-- technical-bibtex-end --&gt;
 *
 &lt;!-- options-start --&gt;
 * Valid options are: &lt;p/&gt;
 * 
 * &lt;pre&gt; -N &amp;lt;number&amp;gt;
 *  The number of dimensions (attributes) the data should be reduced to
 *  (default 10; exclusive of the class attribute, if it is set).&lt;/pre&gt;
 * 
 * &lt;pre&gt; -D [SPARSE1|SPARSE2|GAUSSIAN]
 *  The distribution to use for calculating the random matrix.
 *  Sparse1 is:
 *    sqrt(3)*{-1 with prob(1/6), 0 with prob(2/3), +1 with prob(1/6)}
 *  Sparse2 is:
 *    {-1 with prob(1/2), +1 with prob(1/2)}
 * &lt;/pre&gt;
 * 
 * &lt;pre&gt; -P &amp;lt;percent&amp;gt;
 *  The percentage of dimensions (attributes) the data should
 *  be reduced to (exclusive of the class attribute, if it is set). This -N
 *  option is ignored if this option is present or is greater
 *  than zero.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -M
 *  Replace missing values using the ReplaceMissingValues filter&lt;/pre&gt;
 * 
 * &lt;pre&gt; -R &amp;lt;num&amp;gt;
 *  The random seed for the random number generator used for
 *  calculating the random matrix (default 42).&lt;/pre&gt;
 * 
 &lt;!-- options-end --&gt;
 *
 * @author Ashraf M. Kibriya (amk14@cs.waikato.ac.nz) 
 * @version $Revision: 6750 $ [1.0 - 22 July 2003 - Initial version (Ashraf M. Kibriya)]
 */
<span class="fc" id="L108">public class RandomProjection </span>
  extends Filter 
  implements UnsupervisedFilter, OptionHandler, TechnicalInformationHandler {

  /** for serialization */
  static final long serialVersionUID = 4428905532728645880L;

  /** Stores the number of dimensions to reduce the data to */
<span class="fc" id="L116">  protected int m_k = 10;</span>

  /** Stores the dimensionality the data should be reduced to as percentage of the original dimension */
<span class="fc" id="L119">  protected double m_percent = 0.0;</span>

  /** Is the random matrix will be computed using 
      Gaussian distribution or not */
<span class="fc" id="L123">  protected boolean m_useGaussian = false;</span>

  /** distribution type: sparse 1 */
  public static final int SPARSE1 = 1;
  /** distribution type: sparse 2 */
  public static final int SPARSE2 = 2;
  /** distribution type: gaussian */
  public static final int GAUSSIAN = 3;

  /** The types of distributions that can be used for 
  calculating the random matrix */
<span class="fc" id="L134">  public static final Tag [] TAGS_DSTRS_TYPE = {</span>
    new Tag(SPARSE1, &quot;Sparse1&quot;),
    new Tag(SPARSE2, &quot;Sparse2&quot;),
    new Tag(GAUSSIAN, &quot;Gaussian&quot;),
  };

  /** Stores the distribution to use for calculating the
      random matrix */
<span class="fc" id="L142">  protected int m_distribution = SPARSE1;</span>
 
  /** Should the missing values be replaced using 
      unsupervised.ReplaceMissingValues filter */
<span class="fc" id="L146">  protected boolean m_useReplaceMissing = false;</span>

  /** Keeps track of output format if it is defined or not */
<span class="fc" id="L149">  protected boolean m_OutputFormatDefined = false;</span>

  /** The NominalToBinary filter applied to the data before this filter */
  protected Filter m_ntob; // = new weka.filters.unsupervised.attribute.NominalToBinary();

  /** The ReplaceMissingValues filter */
  protected Filter m_replaceMissing;
    
  /** Stores the random seed used to generate the random matrix */
<span class="fc" id="L158">  protected long m_rndmSeed = 42;</span>

  /** The random matrix */
  protected double m_rmatrix[][];

  /** The random number generator used for generating the random matrix */
  protected Random m_random;

  /**
   * Returns an enumeration describing the available options.
   *
   * @return an enumeration of all the available options.
   */
  public Enumeration listOptions() {

<span class="fc" id="L173">    Vector newVector = new Vector(2);</span>

<span class="fc" id="L175">    newVector.addElement(new Option(</span>
	      &quot;\tThe number of dimensions (attributes) the data should be reduced to\n&quot;
             +&quot;\t(default 10; exclusive of the class attribute, if it is set).&quot;,
	      &quot;N&quot;, 1, &quot;-N &lt;number&gt;&quot;));

<span class="fc" id="L180">    newVector.addElement(new Option(</span>
	      &quot;\tThe distribution to use for calculating the random matrix.\n&quot;
	     +&quot;\tSparse1 is:\n&quot;
	     +&quot;\t  sqrt(3)*{-1 with prob(1/6), 0 with prob(2/3), +1 with prob(1/6)}\n&quot;
	     +&quot;\tSparse2 is:\n&quot;
	     +&quot;\t  {-1 with prob(1/2), +1 with prob(1/2)}\n&quot;,
	      &quot;D&quot;, 1, &quot;-D [SPARSE1|SPARSE2|GAUSSIAN]&quot;));

    //newVector.addElement(new Option(
    //	      &quot;\tUse Gaussian distribution for calculating the random matrix.&quot;,
    //	      &quot;G&quot;, 0, &quot;-G&quot;));

<span class="fc" id="L192">    newVector.addElement(new Option(</span>
	      &quot;\tThe percentage of dimensions (attributes) the data should\n&quot;
	     +&quot;\tbe reduced to (exclusive of the class attribute, if it is set). This -N\n&quot;
	     +&quot;\toption is ignored if this option is present or is greater\n&quot;
	     +&quot;\tthan zero.&quot;,
	      &quot;P&quot;, 1, &quot;-P &lt;percent&gt;&quot;));

<span class="fc" id="L199">    newVector.addElement(new Option(</span>
	      &quot;\tReplace missing values using the ReplaceMissingValues filter&quot;,
	      &quot;M&quot;, 0, &quot;-M&quot;));

<span class="fc" id="L203">    newVector.addElement(new Option(</span>
	      &quot;\tThe random seed for the random number generator used for\n&quot;
	     +&quot;\tcalculating the random matrix (default 42).&quot;,
	      &quot;R&quot;, 0, &quot;-R &lt;num&gt;&quot;));
 
<span class="fc" id="L208">    return newVector.elements();</span>
  }

  /**
   * Parses a given list of options. &lt;p/&gt;
   * 
   &lt;!-- options-start --&gt;
   * Valid options are: &lt;p/&gt;
   * 
   * &lt;pre&gt; -N &amp;lt;number&amp;gt;
   *  The number of dimensions (attributes) the data should be reduced to
   *  (default 10; exclusive of the class attribute, if it is set).&lt;/pre&gt;
   * 
   * &lt;pre&gt; -D [SPARSE1|SPARSE2|GAUSSIAN]
   *  The distribution to use for calculating the random matrix.
   *  Sparse1 is:
   *    sqrt(3)*{-1 with prob(1/6), 0 with prob(2/3), +1 with prob(1/6)}
   *  Sparse2 is:
   *    {-1 with prob(1/2), +1 with prob(1/2)}
   * &lt;/pre&gt;
   * 
   * &lt;pre&gt; -P &amp;lt;percent&amp;gt;
   *  The percentage of dimensions (attributes) the data should
   *  be reduced to (exclusive of the class attribute, if it is set). This -N
   *  option is ignored if this option is present or is greater
   *  than zero.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -M
   *  Replace missing values using the ReplaceMissingValues filter&lt;/pre&gt;
   * 
   * &lt;pre&gt; -R &amp;lt;num&amp;gt;
   *  The random seed for the random number generator used for
   *  calculating the random matrix (default 42).&lt;/pre&gt;
   * 
   &lt;!-- options-end --&gt;
   *
   * @param options the list of options as an array of strings
   * @throws Exception if an option is not supported
   */
  public void setOptions(String[] options) throws Exception {


<span class="fc" id="L250">    String mString = Utils.getOption('P', options);</span>
<span class="pc bpc" id="L251" title="1 of 2 branches missed.">    if (mString.length() != 0) {</span>
<span class="nc" id="L252">	setPercent((double) Double.parseDouble(mString)); //setNumberOfAttributes((int) Integer.parseInt(mString));</span>
    } else {
<span class="fc" id="L254">        setPercent(0);</span>
<span class="fc" id="L255">	mString = Utils.getOption('N', options);</span>
<span class="fc bfc" id="L256" title="All 2 branches covered.">	if (mString.length() != 0) </span>
<span class="fc" id="L257">	    setNumberOfAttributes(Integer.parseInt(mString));	    </span>
	else	    
<span class="fc" id="L259">	    setNumberOfAttributes(10);</span>
    }    
    
<span class="fc" id="L262">    mString = Utils.getOption('R', options);</span>
<span class="fc bfc" id="L263" title="All 2 branches covered.">    if(mString.length()!=0) {</span>
<span class="fc" id="L264">	setRandomSeed( Long.parseLong(mString) );</span>
    }

<span class="fc" id="L267">    mString = Utils.getOption('D', options);</span>
<span class="fc bfc" id="L268" title="All 2 branches covered.">    if(mString.length()!=0) {</span>
<span class="pc bpc" id="L269" title="1 of 2 branches missed.">	if(mString.equalsIgnoreCase(&quot;sparse1&quot;))</span>
<span class="fc" id="L270">	   setDistribution( new SelectedTag(SPARSE1, TAGS_DSTRS_TYPE) );</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">	else if(mString.equalsIgnoreCase(&quot;sparse2&quot;))</span>
<span class="nc" id="L272">	   setDistribution( new SelectedTag(SPARSE2, TAGS_DSTRS_TYPE) );</span>
<span class="nc bnc" id="L273" title="All 2 branches missed.">	else if(mString.equalsIgnoreCase(&quot;gaussian&quot;))</span>
<span class="nc" id="L274">	   setDistribution( new SelectedTag(GAUSSIAN, TAGS_DSTRS_TYPE) );	   </span>
    }

<span class="pc bpc" id="L277" title="1 of 2 branches missed.">    if(Utils.getFlag('M', options))</span>
<span class="nc" id="L278">	setReplaceMissingValues(true);</span>
    else
<span class="fc" id="L280">	setReplaceMissingValues(false);</span>


   //if(Utils.getFlag('G', options))
   //    setUseGaussian(true);
   //else
   //    setUseGaussian(false);
    
<span class="fc" id="L288">  }</span>

  /**
   * Gets the current settings of the filter.
   *
   * @return an array of strings suitable for passing to setOptions
   */
  public String [] getOptions() {

<span class="fc" id="L297">    String [] options = new String [10];</span>
<span class="fc" id="L298">    int current = 0;</span>

    //if (getUseGaussian()) {
    //  options[current++] = &quot;-G&quot;;
    //}

<span class="pc bpc" id="L304" title="1 of 2 branches missed.">    if (getReplaceMissingValues()) {</span>
<span class="nc" id="L305">      options[current++] = &quot;-M&quot;;</span>
    }

<span class="pc bpc" id="L308" title="1 of 2 branches missed.">    if (getPercent() == 0) {</span>
<span class="fc" id="L309">      options[current++] = &quot;-N&quot;;</span>
<span class="fc" id="L310">      options[current++] = &quot;&quot; + getNumberOfAttributes();</span>
    }
    else {
<span class="nc" id="L313">      options[current++] = &quot;-P&quot;;</span>
<span class="nc" id="L314">      options[current++] = &quot;&quot; + getPercent();</span>
    }
    
<span class="fc" id="L317">    options[current++] = &quot;-R&quot;;</span>
<span class="fc" id="L318">    options[current++] = &quot;&quot; + getRandomSeed();</span>
    
<span class="fc" id="L320">    SelectedTag t = getDistribution();</span>
<span class="fc" id="L321">    options[current++] = &quot;-D&quot;;</span>
<span class="fc" id="L322">    options[current++] = &quot;&quot;+t.getSelectedTag().getReadable();</span>


<span class="fc bfc" id="L325" title="All 2 branches covered.">    while (current &lt; options.length) {</span>
<span class="fc" id="L326">      options[current++] = &quot;&quot;;</span>
    }

<span class="fc" id="L329">    return options;</span>
  }
    
   
  /**
   * Returns a string describing this filter
   *
   * @return a description of the filter suitable for
   * displaying in the explorer/experimenter gui
   */
  public String globalInfo() {

<span class="nc" id="L341">    return &quot;Reduces the dimensionality of the data by projecting&quot;</span>
	 + &quot; it onto a lower dimensional subspace using a random&quot;
	 + &quot; matrix with columns of unit length (i.e. It will reduce&quot;
	 + &quot; the number of attributes in the data while preserving&quot;
	 + &quot; much of its variation like PCA, but at a much less&quot;
	 + &quot; computational cost).\n&quot;
	 + &quot;It first applies the  NominalToBinary filter to&quot; 
	 + &quot; convert all attributes to numeric before reducing the&quot;
	 + &quot; dimension. It preserves the class attribute.\n\n&quot;
	 + &quot;For more information, see:\n\n&quot;
<span class="nc" id="L351">	 + getTechnicalInformation().toString();</span>
  }

  /**
   * Returns an instance of a TechnicalInformation object, containing 
   * detailed information about the technical background of this class,
   * e.g., paper reference or book this class is based on.
   * 
   * @return the technical information about this class
   */
  public TechnicalInformation getTechnicalInformation() {
    TechnicalInformation 	result;
    
<span class="nc" id="L364">    result = new TechnicalInformation(Type.INPROCEEDINGS);</span>
<span class="nc" id="L365">    result.setValue(Field.AUTHOR, &quot;Dmitriy Fradkin and David Madigan&quot;);</span>
<span class="nc" id="L366">    result.setValue(Field.TITLE, &quot;Experiments with random projections for machine learning&quot;);</span>
<span class="nc" id="L367">    result.setValue(Field.BOOKTITLE, &quot;KDD '03: Proceedings of the ninth ACM SIGKDD international conference on Knowledge discovery and data mining&quot;);</span>
<span class="nc" id="L368">    result.setValue(Field.YEAR, &quot;003&quot;);</span>
<span class="nc" id="L369">    result.setValue(Field.PAGES, &quot;517-522&quot;);</span>
<span class="nc" id="L370">    result.setValue(Field.PUBLISHER, &quot;ACM Press&quot;);</span>
<span class="nc" id="L371">    result.setValue(Field.ADDRESS, &quot;New York, NY, USA&quot;);</span>
    
<span class="nc" id="L373">    return result;</span>
  }

  /**
   * Returns the tip text for this property
   *
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String numberOfAttributesTipText() {

<span class="nc" id="L384">    return &quot;The number of dimensions (attributes) the data should&quot;</span>
         + &quot; be reduced to.&quot;;
  }

  /** 
   * Sets the number of attributes (dimensions) the data should be reduced to
   * 
   * @param newAttNum the goal for the dimensions
   */
  public void setNumberOfAttributes(int newAttNum) {
<span class="fc" id="L394">      m_k = newAttNum;</span>
<span class="fc" id="L395">  }</span>
  
  /** 
   * Gets the current number of attributes (dimensionality) to which the data 
   * will be reduced to.
   *  
   * @return the number of dimensions
   */
  public int getNumberOfAttributes() {
<span class="fc" id="L404">      return m_k;</span>
  }

  /**
   * Returns the tip text for this property
   *
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String percentTipText() {

<span class="nc" id="L415">      return  &quot; The percentage of dimensions (attributes) the data should&quot;</span>
            + &quot; be reduced to  (inclusive of the class attribute). This &quot;
	    + &quot; NumberOfAttributes option is ignored if this option is&quot;
	    + &quot; present or is greater than zero.&quot;;
  }

  /** 
   * Sets the percent the attributes (dimensions) of the data should be reduced to
   * 
   * @param newPercent the percentage of attributes
   */
  public void setPercent(double newPercent) {
<span class="pc bpc" id="L427" title="1 of 2 branches missed.">      if(newPercent &gt; 0)</span>
<span class="nc" id="L428">	  newPercent /= 100;</span>
<span class="fc" id="L429">      m_percent = newPercent;</span>
<span class="fc" id="L430">  }</span>

  /** 
   * Gets the percent the attributes (dimensions) of the data will be reduced to
   * 
   * @return the percentage of attributes
   */
  public double getPercent() {
<span class="fc" id="L438">      return m_percent * 100;</span>
  }


  /**
   * Returns the tip text for this property
   *
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String randomSeedTipText() {
<span class="nc" id="L449">      return  &quot;The random seed used by the random&quot;</span>
	     +&quot; number generator used for generating&quot;
	     +&quot; the random matrix &quot;;
  }

  /** 
   * Sets the random seed of the random number generator
   * 
   * @param seed the random seed value
   */
  public void setRandomSeed(long seed) {
<span class="fc" id="L460">      m_rndmSeed = seed;</span>
<span class="fc" id="L461">  }</span>

  /** 
   * Gets the random seed of the random number generator
   * 
   * @return the random seed value
   */
  public long getRandomSeed() {
<span class="fc" id="L469">      return m_rndmSeed;</span>
  }


  /**
   * Returns the tip text for this property
   *
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String  distributionTipText() {
<span class="nc" id="L480">      return &quot;The distribution to use for calculating the random matrix.\n&quot;</span>
	    +&quot;Sparse1 is:\n&quot;
	    +&quot; sqrt(3) * { -1 with prob(1/6), \n&quot;
	    +&quot;               0 with prob(2/3),  \n&quot;
            +&quot;              +1 with prob(1/6) } \n&quot;
	    +&quot;Sparse2 is:\n&quot;
	    +&quot; { -1 with prob(1/2), \n&quot;
	    +&quot;   +1 with prob(1/2) } &quot;;
      
  }
  /** 
   * Sets the distribution to use for calculating the random matrix
   * 
   * @param newDstr the distribution to use
   */
  public void setDistribution(SelectedTag newDstr) {

<span class="pc bpc" id="L497" title="1 of 2 branches missed.">      if (newDstr.getTags() == TAGS_DSTRS_TYPE) {</span>
<span class="fc" id="L498">	  m_distribution = newDstr.getSelectedTag().getID();</span>
      }
<span class="fc" id="L500">  }</span>

  /** 
   * Returns the current distribution that'll be used for calculating the 
   * random matrix
   * 
   * @return the current distribution
   */
  public SelectedTag getDistribution() {
<span class="fc" id="L509">      return new SelectedTag(m_distribution, TAGS_DSTRS_TYPE);</span>
  }

  /**
   * Returns the tip text for this property
   *
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String replaceMissingValuesTipText() {

<span class="nc" id="L520">    return &quot;If set the filter uses weka.filters.unsupervised.attribute.ReplaceMissingValues&quot;</span>
	 + &quot; to replace the missing values&quot;;
  }

  /** 
   * Sets either to use replace missing values filter or not
   * 
   * @param t if true then the replace missing values is used
   */
  public void setReplaceMissingValues(boolean t) {
<span class="fc" id="L530">      m_useReplaceMissing = t;</span>
<span class="fc" id="L531">  }</span>

  /** 
   * Gets the current setting for using ReplaceMissingValues filter
   * 
   * @return true if the replace missing values filter is used
   */
  public boolean getReplaceMissingValues() {
<span class="fc" id="L539">      return m_useReplaceMissing;</span>
  }

  /** 
   * Returns the Capabilities of this filter.
   *
   * @return            the capabilities of this object
   * @see               Capabilities
   */
  public Capabilities getCapabilities() {
<span class="fc" id="L549">    Capabilities result = super.getCapabilities();</span>
<span class="fc" id="L550">    result.disableAll();</span>

    // attributes
<span class="fc" id="L553">    result.enableAllAttributes();</span>
<span class="fc" id="L554">    result.enable(Capability.MISSING_VALUES);</span>
    
    // class
<span class="fc" id="L557">    result.enableAllClasses();</span>
<span class="fc" id="L558">    result.enable(Capability.MISSING_CLASS_VALUES);</span>
<span class="fc" id="L559">    result.enable(Capability.NO_CLASS);</span>
    
<span class="fc" id="L561">    return result;</span>
  }

  /**
   * Sets the format of the input instances.
   *
   * @param instanceInfo an Instances object containing the input 
   * instance structure (any instances contained in the object are 
   * ignored - only the structure is required).
   * @return true if the outputFormat may be collected immediately
   * @throws Exception if the input format can't be set 
   * successfully
   */
  public boolean setInputFormat(Instances instanceInfo) throws Exception {      
<span class="fc" id="L575">    super.setInputFormat(instanceInfo);</span>
    /*
    if (instanceInfo.classIndex() &lt; 0) {
      throw new UnassignedClassException(&quot;No class has been assigned to the instances&quot;);
    }
    */
    
<span class="pc bpc" id="L582" title="1 of 2 branches missed.">    for(int i=0; i&lt;instanceInfo.numAttributes(); i++) {        </span>
<span class="fc bfc" id="L583" title="All 4 branches covered.">	if( i!=instanceInfo.classIndex() &amp;&amp; instanceInfo.attribute(i).isNominal() ) {</span>
<span class="pc bpc" id="L584" title="1 of 2 branches missed.">            if(instanceInfo.classIndex()&gt;=0)</span>
<span class="fc" id="L585">                m_ntob = new weka.filters.supervised.attribute.NominalToBinary();</span>
            else
<span class="nc" id="L587">                m_ntob = new weka.filters.unsupervised.attribute.NominalToBinary();</span>
            
<span class="nc" id="L589">            break;</span>
	}
    }

    //r.setSeed(m_rndmSeed); //in case the setRandomSeed() is not
                           //called we better set the seed to its 
                           //default value of 42.
<span class="fc" id="L596">    boolean temp=true;</span>
<span class="pc bpc" id="L597" title="1 of 2 branches missed.">    if(m_replaceMissing!=null) {</span>
<span class="nc" id="L598">	m_replaceMissing = new weka.filters.unsupervised.attribute.ReplaceMissingValues();</span>
<span class="nc bnc" id="L599" title="All 2 branches missed.">	if(m_replaceMissing.setInputFormat(instanceInfo))</span>
<span class="nc" id="L600">	    temp=true;</span>
	else
<span class="nc" id="L602">	    temp=false;</span>
    }
    
<span class="pc bpc" id="L605" title="1 of 2 branches missed.">    if(m_ntob!=null) {</span>
<span class="pc bpc" id="L606" title="1 of 2 branches missed.">	if(m_ntob.setInputFormat(instanceInfo)) {</span>
<span class="fc" id="L607">	    setOutputFormat();</span>
<span class="pc bpc" id="L608" title="1 of 2 branches missed.">	    return temp &amp;&amp; true;</span>
	}
	else { 
<span class="nc" id="L611">	    return false;</span>
	}
    }
    else {
<span class="nc" id="L615">	setOutputFormat();</span>
<span class="nc bnc" id="L616" title="All 2 branches missed.">	return temp &amp;&amp; true;</span>
    }
  }

   
  /**
   * Input an instance for filtering.
   *
   * @param instance the input instance
   * @return true if the filtered instance may now be
   * collected with output().
   * @throws IllegalStateException if no input format has been set
   */
  public boolean input(Instance instance) throws Exception {

<span class="fc" id="L631">    Instance newInstance=null;</span>

<span class="pc bpc" id="L633" title="1 of 2 branches missed.">    if (getInputFormat()==null) {</span>
<span class="nc" id="L634">	throw new IllegalStateException(&quot;No input instance format defined&quot;);</span>
    }
<span class="fc bfc" id="L636" title="All 2 branches covered.">    if(m_NewBatch) {</span>
<span class="fc" id="L637">      resetQueue();</span>
      //if(ntob!=null) 
      //	  ntob.m_NewBatch=true;
<span class="fc" id="L640">      m_NewBatch = false;</span>
    }
    
<span class="fc" id="L643">    boolean replaceDone=false;</span>
<span class="pc bpc" id="L644" title="1 of 2 branches missed.">    if(m_replaceMissing!=null) {</span>
<span class="nc bnc" id="L645" title="All 2 branches missed.">	if(m_replaceMissing.input(instance)) {</span>
<span class="nc bnc" id="L646" title="All 2 branches missed.">	    if(m_OutputFormatDefined == false)</span>
<span class="nc" id="L647">		setOutputFormat();</span>
<span class="nc" id="L648">	    newInstance = m_replaceMissing.output();</span>
<span class="nc" id="L649">	    replaceDone = true;</span>
	}
	else
<span class="nc" id="L652">	    return false;;</span>
    }

<span class="pc bpc" id="L655" title="1 of 2 branches missed.">    if(m_ntob!=null) {</span>
<span class="pc bpc" id="L656" title="1 of 2 branches missed.">	if(replaceDone==false)</span>
<span class="fc" id="L657">	    newInstance = instance;</span>
<span class="pc bpc" id="L658" title="1 of 2 branches missed.">	if(m_ntob.input(newInstance)) {</span>
<span class="fc bfc" id="L659" title="All 2 branches covered.">	    if(m_OutputFormatDefined == false) </span>
<span class="fc" id="L660">		setOutputFormat();</span>
<span class="fc" id="L661">	    newInstance = m_ntob.output();</span>
<span class="fc" id="L662">	    newInstance = convertInstance(newInstance);</span>
<span class="fc" id="L663">	    push(newInstance);</span>
<span class="fc" id="L664">	    return true;	</span>
	}
	else {
<span class="nc" id="L667">	    return false;</span>
	}
    }
    else {
<span class="nc bnc" id="L671" title="All 2 branches missed.">	if(replaceDone==false)</span>
<span class="nc" id="L672">	    newInstance = instance;</span>
<span class="nc" id="L673">	newInstance = convertInstance(newInstance);</span>
<span class="nc" id="L674">	push(newInstance);</span>
<span class="nc" id="L675">	return true;</span>
    }
  }


  /**
   * Signify that this batch of input to the filter is finished.
   *
   * @return true if there are instances pending output
   * @throws NullPointerException if no input structure has been defined,
   * @throws Exception if there was a problem finishing the batch.
   */
  public boolean batchFinished() throws Exception {
<span class="pc bpc" id="L688" title="1 of 2 branches missed.">      if (getInputFormat() == null) {</span>
<span class="nc" id="L689">	  throw new NullPointerException(&quot;No input instance format defined&quot;);</span>
      }
      
<span class="fc" id="L692">      boolean conversionDone=false;</span>
<span class="pc bpc" id="L693" title="1 of 2 branches missed.">      if(m_replaceMissing!=null) {</span>
<span class="nc bnc" id="L694" title="All 2 branches missed.">	  if(m_replaceMissing.batchFinished()) {</span>
	      Instance newInstance, instance;
	      
<span class="nc bnc" id="L697" title="All 2 branches missed.">	      while((instance=m_replaceMissing.output())!=null) {</span>
<span class="nc bnc" id="L698" title="All 2 branches missed.">		  if(!m_OutputFormatDefined)</span>
<span class="nc" id="L699">		      setOutputFormat();</span>
<span class="nc bnc" id="L700" title="All 2 branches missed.">		  if(m_ntob!=null) {</span>
<span class="nc" id="L701">		      m_ntob.input(instance);</span>
		  }
		  else {
<span class="nc" id="L704">		      newInstance = convertInstance(instance);</span>
<span class="nc" id="L705">		      push(newInstance);</span>
		  }
	      }

<span class="nc bnc" id="L709" title="All 2 branches missed.">	      if(m_ntob!=null) {</span>
<span class="nc bnc" id="L710" title="All 2 branches missed.">		  if(m_ntob.batchFinished()) {</span>
		      //Instance newInstance, instance;
<span class="nc bnc" id="L712" title="All 2 branches missed.">		      while((instance=m_ntob.output())!=null) {</span>
<span class="nc bnc" id="L713" title="All 2 branches missed.">			  if(!m_OutputFormatDefined)</span>
<span class="nc" id="L714">			      setOutputFormat();</span>
<span class="nc" id="L715">			  newInstance = convertInstance(instance);</span>
<span class="nc" id="L716">			  push(newInstance);</span>
		      }
<span class="nc" id="L718">		      m_ntob = null;		      </span>
		  }
	      }
<span class="nc" id="L721">	      m_replaceMissing = null;</span>
<span class="nc" id="L722">	      conversionDone=true;</span>
	  }
      }

<span class="pc bpc" id="L726" title="2 of 4 branches missed.">      if(conversionDone==false &amp;&amp; m_ntob!=null) {</span>
<span class="pc bpc" id="L727" title="1 of 2 branches missed.">	  if(m_ntob.batchFinished()) {</span>
	      Instance newInstance, instance;
<span class="nc bnc" id="L729" title="All 2 branches missed.">	      while((instance=m_ntob.output())!=null) {</span>
<span class="nc bnc" id="L730" title="All 2 branches missed.">		  if(!m_OutputFormatDefined)</span>
<span class="nc" id="L731">		      setOutputFormat();</span>
<span class="nc" id="L732">		  newInstance = convertInstance(instance);</span>
<span class="nc" id="L733">		  push(newInstance);</span>
	      }
<span class="nc" id="L735">	      m_ntob = null;</span>
	  }
      }
<span class="fc" id="L738">      m_OutputFormatDefined=false;</span>
<span class="fc" id="L739">      return super.batchFinished();</span>
  }
    

  /** Sets the output format */  
  protected void setOutputFormat() {
      Instances currentFormat;
<span class="pc bpc" id="L746" title="1 of 2 branches missed.">      if(m_ntob!=null) {</span>
<span class="fc" id="L747">	  currentFormat = m_ntob.getOutputFormat();</span>
      }
      else 
<span class="nc" id="L750">	  currentFormat = getInputFormat();</span>
      
<span class="pc bpc" id="L752" title="1 of 2 branches missed.">      if(m_percent&gt;0)</span>
<span class="nc" id="L753">	  { m_k = (int) ((getInputFormat().numAttributes()-1)*m_percent); </span>
	  // System.out.print(&quot;numAtts: &quot;+currentFormat.numAttributes());
	  // System.out.print(&quot;percent: &quot;+m_percent);
	  // System.out.print(&quot;percent*numAtts: &quot;+(currentFormat.numAttributes()*m_percent));
	  // System.out.println(&quot;m_k: &quot;+m_k);
	  }

      Instances newFormat;
<span class="fc" id="L761">      int newClassIndex=-1;</span>
<span class="fc" id="L762">      FastVector attributes = new FastVector();</span>
<span class="fc bfc" id="L763" title="All 2 branches covered.">      for(int i=0; i&lt;m_k; i++) {</span>
<span class="fc" id="L764">	  attributes.addElement( new Attribute(&quot;K&quot;+(i+1)) );</span>
      }
<span class="pc bpc" id="L766" title="1 of 2 branches missed.">      if(currentFormat.classIndex()!=-1)  {  //if classindex is set</span>
	  //attributes.removeElementAt(attributes.size()-1);
<span class="fc" id="L768">	  attributes.addElement(currentFormat.attribute(currentFormat.classIndex()));</span>
<span class="fc" id="L769">	  newClassIndex = attributes.size()-1;</span>
      }

<span class="fc" id="L772">      newFormat = new Instances(currentFormat.relationName(), attributes, 0);</span>
<span class="pc bpc" id="L773" title="1 of 2 branches missed.">      if(newClassIndex!=-1)</span>
<span class="fc" id="L774">	  newFormat.setClassIndex(newClassIndex);</span>
<span class="fc" id="L775">      m_OutputFormatDefined=true;</span>

<span class="fc" id="L777">      m_random = new Random();</span>
<span class="fc" id="L778">      m_random.setSeed(m_rndmSeed);</span>

<span class="fc" id="L780">      m_rmatrix = new double[m_k][currentFormat.numAttributes()];</span>
<span class="fc bfc" id="L781" title="All 2 branches covered.">      if(m_distribution==GAUSSIAN) {</span>
<span class="fc bfc" id="L782" title="All 2 branches covered.">	  for(int i=0; i&lt;m_rmatrix.length; i++) </span>
<span class="fc bfc" id="L783" title="All 2 branches covered.">	      for(int j=0; j&lt;m_rmatrix[i].length; j++) </span>
<span class="fc" id="L784">		  m_rmatrix[i][j] = m_random.nextGaussian();</span>
      }
      else {
<span class="fc bfc" id="L787" title="All 2 branches covered.">	  boolean useDstrWithZero = (m_distribution==SPARSE1);</span>
<span class="fc bfc" id="L788" title="All 2 branches covered.">	  for(int i=0; i&lt;m_rmatrix.length; i++) </span>
<span class="fc bfc" id="L789" title="All 2 branches covered.">	      for(int j=0; j&lt;m_rmatrix[i].length; j++) </span>
<span class="fc" id="L790">		  m_rmatrix[i][j] = rndmNum(useDstrWithZero);</span>
      }

<span class="fc" id="L793">      setOutputFormat(newFormat);</span>
<span class="fc" id="L794">  }</span>

  /**
   * converts a single instance to the required format
   *
   * @param currentInstance     the instance to convert
   * @return                    the converted instance
   */
  protected Instance convertInstance(Instance currentInstance) {

      Instance newInstance;
<span class="fc" id="L805">      double vals[] = new double[getOutputFormat().numAttributes()];</span>
<span class="pc bpc" id="L806" title="1 of 2 branches missed.">      int classIndex = (m_ntob==null) ? getInputFormat().classIndex():m_ntob.getOutputFormat().classIndex();</span>

<span class="fc bfc" id="L808" title="All 2 branches covered.">      for(int i = 0; i &lt; m_k; i++) {</span>
<span class="fc" id="L809">        vals[i] = computeRandomProjection(i,classIndex,currentInstance);</span>
      }
<span class="pc bpc" id="L811" title="1 of 2 branches missed.">      if (classIndex != -1) {</span>
<span class="fc" id="L812">        vals[m_k] = currentInstance.value(classIndex);</span>
      }

<span class="fc" id="L815">      newInstance = new Instance(currentInstance.weight(), vals);</span>
<span class="fc" id="L816">      newInstance.setDataset(getOutputFormat());</span>

<span class="fc" id="L818">      return newInstance;</span>
  }


  /**
   * computes one random projection for a given instance (skip missing values)
   *
   * @param rpIndex     offset the new random projection attribute
   * @param classIndex  classIndex of the input instance
   * @param instance    the instance to convert
   * @return    the random sum
   */

  protected double computeRandomProjection(int rpIndex, int classIndex, Instance instance) {

<span class="fc" id="L833">    double sum = 0.0;</span>
<span class="fc bfc" id="L834" title="All 2 branches covered.">    for(int i = 0; i &lt; instance.numValues(); i++) {</span>
<span class="fc" id="L835">      int index = instance.index(i);</span>
<span class="fc bfc" id="L836" title="All 2 branches covered.">      if (index != classIndex) {</span>
<span class="fc" id="L837">        double value = instance.valueSparse(i);</span>
<span class="fc bfc" id="L838" title="All 2 branches covered.">        if (!Instance.isMissingValue(value)) {</span>
<span class="fc" id="L839">          sum += m_rmatrix[rpIndex][index] * value;</span>
        }
      }
    }
<span class="fc" id="L843">    return sum;</span>
  }

<span class="fc" id="L846">  private static final int weights[] = {1, 1, 4};</span>
<span class="fc" id="L847">  private static final int vals[] = {-1, 1, 0};</span>
<span class="fc" id="L848">  private static final int weights2[] = {1, 1};</span>
<span class="fc" id="L849">  private static final int vals2[] = {-1, 1};</span>
<span class="fc" id="L850">  private static final double sqrt3 = Math.sqrt(3);</span>

  /**
   * returns a double x such that &lt;br/&gt;
   *      x = sqrt(3) * { -1 with prob. 1/6, 0 with prob. 2/3, 1 with prob. 1/6 }
   *      
   * @param useDstrWithZero
   * @return the generated number
   */
  protected double rndmNum(boolean useDstrWithZero) {
<span class="fc bfc" id="L860" title="All 2 branches covered.">      if(useDstrWithZero)</span>
<span class="fc" id="L861">	  return sqrt3 * vals[weightedDistribution(weights)];</span>
      else
<span class="fc" id="L863">	  return vals2[weightedDistribution(weights2)];</span>
  }

  /** 
   * Calculates a weighted distribution
   * 
   * @param weights the weights to use
   * @return
   */
  protected int weightedDistribution(int [] weights) {
<span class="fc" id="L873">      int sum=0; </span>
      
<span class="fc bfc" id="L875" title="All 2 branches covered.">      for(int i=0; i&lt;weights.length; i++) </span>
<span class="fc" id="L876">	  sum += weights[i];</span>
      
<span class="fc" id="L878">      int val = (int)Math.floor(m_random.nextDouble()*sum);</span>
      
<span class="pc bpc" id="L880" title="1 of 2 branches missed.">      for(int i=0; i&lt;weights.length; i++) {</span>
<span class="fc" id="L881">	  val -= weights[i];</span>
<span class="fc bfc" id="L882" title="All 2 branches covered.">	  if(val&lt;0)</span>
<span class="fc" id="L883">	      return i;</span>
      }
<span class="nc" id="L885">      return -1;</span>
  }  
  
  /**
   * Returns the revision string.
   * 
   * @return		the revision
   */
  public String getRevision() {
<span class="nc" id="L894">    return RevisionUtils.extract(&quot;$Revision: 6750 $&quot;);</span>
  }

  /**
   * Main method for testing this class.
   *
   * @param argv should contain arguments to the filter: 
   * use -h for help
   */
  public static void main(String [] argv) {
<span class="nc" id="L904">    runFilter(new RandomProjection(), argv);</span>
<span class="nc" id="L905">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>
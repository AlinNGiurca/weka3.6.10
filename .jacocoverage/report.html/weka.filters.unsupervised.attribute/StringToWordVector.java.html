<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>StringToWordVector.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCoverage analysis of project &quot;Weka-3.6.10&quot; (powered by JaCoCo from EclEmma)</a> &gt; <a href="index.source.html" class="el_package">weka.filters.unsupervised.attribute</a> &gt; <span class="el_source">StringToWordVector.java</span></div><h1>StringToWordVector.java</h1><pre class="source lang-java linenums">/*
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation; either version 2 of the License, or
 *    (at your option) any later version.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not, write to the Free Software
 *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/*
 *    StringToWordVector.java
 *    Copyright (C) 2002 University of Waikato, Hamilton, New Zealand
 *
 */

package weka.filters.unsupervised.attribute;

import weka.core.Attribute;
import weka.core.Capabilities;
import weka.core.FastVector;
import weka.core.Instance;
import weka.core.Instances;
import weka.core.Option;
import weka.core.OptionHandler;
import weka.core.Range;
import weka.core.RevisionHandler;
import weka.core.RevisionUtils;
import weka.core.SelectedTag;
import weka.core.SparseInstance;
import weka.core.Stopwords;
import weka.core.Tag;
import weka.core.Utils;
import weka.core.Capabilities.Capability;
import weka.core.stemmers.NullStemmer;
import weka.core.stemmers.Stemmer;
import weka.core.tokenizers.Tokenizer;
import weka.core.tokenizers.WordTokenizer;
import weka.filters.Filter;
import weka.filters.UnsupervisedFilter;

import java.io.File;
import java.io.Serializable;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.TreeMap;
import java.util.Vector;

/** 
 &lt;!-- globalinfo-start --&gt;
 * Converts String attributes into a set of attributes representing word occurrence (depending on the tokenizer) information from the text contained in the strings. The set of words (attributes) is determined by the first batch filtered (typically training data).
 * &lt;p/&gt;
 &lt;!-- globalinfo-end --&gt;
 * 
 &lt;!-- options-start --&gt;
 * Valid options are: &lt;p/&gt;
 * 
 * &lt;pre&gt; -C
 *  Output word counts rather than boolean word presence.
 * &lt;/pre&gt;
 * 
 * &lt;pre&gt; -R &amp;lt;index1,index2-index4,...&amp;gt;
 *  Specify list of string attributes to convert to words (as weka Range).
 *  (default: select all string attributes)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -V
 *  Invert matching sense of column indexes.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -P &amp;lt;attribute name prefix&amp;gt;
 *  Specify a prefix for the created attribute names.
 *  (default: &quot;&quot;)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -W &amp;lt;number of words to keep&amp;gt;
 *  Specify approximate number of word fields to create.
 *  Surplus words will be discarded..
 *  (default: 1000)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -prune-rate &amp;lt;rate as a percentage of dataset&amp;gt;
 *  Specify the rate (e.g., every 10% of the input dataset) at which to periodically prune the dictionary.
 *  -W prunes after creating a full dictionary. You may not have enough memory for this approach.
 *  (default: no periodic pruning)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -T
 *  Transform the word frequencies into log(1+fij)
 *  where fij is the frequency of word i in jth document(instance).
 * &lt;/pre&gt;
 * 
 * &lt;pre&gt; -I
 *  Transform each word frequency into:
 *  fij*log(num of Documents/num of documents containing word i)
 *    where fij if frequency of word i in jth document(instance)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -N
 *  Whether to 0=not normalize/1=normalize all data/2=normalize test data only
 *  to average length of training documents (default 0=don't normalize).&lt;/pre&gt;
 * 
 * &lt;pre&gt; -L
 *  Convert all tokens to lowercase before adding to the dictionary.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -S
 *  Ignore words that are in the stoplist.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -stemmer &amp;lt;spec&amp;gt;
 *  The stemmering algorihtm (classname plus parameters) to use.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -M &amp;lt;int&amp;gt;
 *  The minimum term frequency (default = 1).&lt;/pre&gt;
 * 
 * &lt;pre&gt; -O
 *  If this is set, the maximum number of words and the 
 *  minimum term frequency is not enforced on a per-class 
 *  basis but based on the documents in all the classes 
 *  (even if a class attribute is set).&lt;/pre&gt;
 * 
 * &lt;pre&gt; -stopwords &amp;lt;file&amp;gt;
 *  A file containing stopwords to override the default ones.
 *  Using this option automatically sets the flag ('-S') to use the
 *  stoplist if the file exists.
 *  Format: one stopword per line, lines starting with '#'
 *  are interpreted as comments and ignored.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -tokenizer &amp;lt;spec&amp;gt;
 *  The tokenizing algorihtm (classname plus parameters) to use.
 *  (default: weka.core.tokenizers.WordTokenizer)&lt;/pre&gt;
 * 
 &lt;!-- options-end --&gt;
 *
 * @author Len Trigg (len@reeltwo.com)
 * @author Stuart Inglis (stuart@reeltwo.com)
 * @author Gordon Paynter (gordon.paynter@ucr.edu)
 * @author Asrhaf M. Kibriya (amk14@cs.waikato.ac.nz)
 * @version $Revision: 9565 $ 
 * @see Stopwords
 */
public class StringToWordVector 
  extends Filter
  implements UnsupervisedFilter, OptionHandler {

  /** for serialization. */
  static final long serialVersionUID = 8249106275278565424L;

  /** Range of columns to convert to word vectors. */
<span class="pc" id="L150">  protected Range m_SelectedRange = new Range(&quot;first-last&quot;);</span>

  /** Contains a mapping of valid words to attribute indexes. */
<span class="pc" id="L153">  private TreeMap m_Dictionary = new TreeMap();</span>

  /** True if output instances should contain word frequency rather than boolean 0 or 1. */
<span class="pc" id="L156">  private boolean m_OutputCounts = false;</span>

  /** A String prefix for the attribute names. */
<span class="pc" id="L159">  private String m_Prefix = &quot;&quot;;</span>

  /** Contains the number of documents (instances) a particular word appears in.
          The counts are stored with the same indexing as given by m_Dictionary.  */
  private int [] m_DocsCounts;

  /** Contains the number of documents (instances) in the input format from 
          which the dictionary is created. It is used in IDF transform. */
<span class="pc" id="L167">  private int m_NumInstances = -1;</span>

  /**
   * Contains the average length of documents (among the first batch of 
   * instances aka training data). This is used in length normalization of 
   * documents which will be normalized to average document length.
   */
<span class="pc" id="L174">  private double m_AvgDocLength = -1;</span>

  /**
   * The default number of words (per class if there is a class attribute
   * assigned) to attempt to keep.
   */
<span class="pc" id="L180">  private int m_WordsToKeep = 1000;</span>

  /**
   * The percentage at which to periodically prune the dictionary.
   */
<span class="pc" id="L185">  private double m_PeriodicPruningRate = -1;</span>

  /** True if word frequencies should be transformed into log(1+fi) 
          where fi is the frequency of word i.
   */
  private boolean m_TFTransform;

  /** The normalization to apply. */
<span class="pc" id="L193">  protected int m_filterType = FILTER_NONE;</span>

  /** normalization: No normalization. */
  public static final int FILTER_NONE = 0;
  /** normalization: Normalize all data. */
  public static final int FILTER_NORMALIZE_ALL = 1;
  /** normalization: Normalize test data only. */
  public static final int FILTER_NORMALIZE_TEST_ONLY = 2;

  /** Specifies whether document's (instance's) word frequencies are
   * to be normalized.  The are normalized to average length of
   * documents specified as input format. */
<span class="fc" id="L205">  public static final Tag [] TAGS_FILTER = {</span>
    new Tag(FILTER_NONE, &quot;No normalization&quot;),
    new Tag(FILTER_NORMALIZE_ALL, &quot;Normalize all data&quot;),
    new Tag(FILTER_NORMALIZE_TEST_ONLY, &quot;Normalize test data only&quot;),
  };

  /** True if word frequencies should be transformed into 
          fij*log(numOfDocs/numOfDocsWithWordi). */
  private boolean m_IDFTransform;

  /** True if all tokens should be downcased. */
  private boolean m_lowerCaseTokens;

  /** True if tokens that are on a stoplist are to be ignored. */
  private boolean m_useStoplist;  

  /** the stemming algorithm. */
<span class="pc" id="L222">  private Stemmer m_Stemmer = new NullStemmer();</span>

  /** the minimum (per-class) word frequency. */
<span class="pc" id="L225">  private int m_minTermFreq = 1;</span>

  /** whether to operate on a per-class basis. */
<span class="pc" id="L228">  private boolean m_doNotOperateOnPerClassBasis = false;</span>

  /** a file containing stopwords for using others than the default Rainbow 
   * ones. */
<span class="pc" id="L232">  private File m_Stopwords = new File(System.getProperty(&quot;user.dir&quot;));</span>

  /** the tokenizer algorithm to use. */
<span class="pc" id="L235">  private Tokenizer m_Tokenizer = new WordTokenizer();</span>

  /**
   * Default constructor. Targets 1000 words in the output.
   */
<span class="fc" id="L240">  public StringToWordVector() {</span>
<span class="fc" id="L241">  }</span>

  /**
   * Returns an enumeration describing the available options.
   *
   * @return an enumeration of all the available options
   */
  public Enumeration listOptions() {
<span class="fc" id="L249">    Vector result = new Vector();</span>

<span class="fc" id="L251">    result.addElement(new Option(</span>
	&quot;\tOutput word counts rather than boolean word presence.\n&quot;,
	&quot;C&quot;, 0, &quot;-C&quot;));

<span class="fc" id="L255">    result.addElement(new Option(</span>
	&quot;\tSpecify list of string attributes to convert to words (as weka Range).\n&quot;
	+ &quot;\t(default: select all string attributes)&quot;,
	&quot;R&quot;, 1, &quot;-R &lt;index1,index2-index4,...&gt;&quot;));

<span class="fc" id="L260">    result.addElement(new Option(</span>
	&quot;\tInvert matching sense of column indexes.&quot;,
	&quot;V&quot;, 0, &quot;-V&quot;));

<span class="fc" id="L264">    result.addElement(new Option(</span>
	&quot;\tSpecify a prefix for the created attribute names.\n&quot;
	+ &quot;\t(default: \&quot;\&quot;)&quot;,
	&quot;P&quot;, 1, &quot;-P &lt;attribute name prefix&gt;&quot;));

<span class="fc" id="L269">    result.addElement(new Option(</span>
	&quot;\tSpecify approximate number of word fields to create.\n&quot;
	+ &quot;\tSurplus words will be discarded..\n&quot;
	+ &quot;\t(default: 1000)&quot;,
	&quot;W&quot;, 1, &quot;-W &lt;number of words to keep&gt;&quot;));

<span class="fc" id="L275">    result.addElement(new Option(</span>
	&quot;\tSpecify the rate (e.g., every 10% of the input dataset) at which to periodically prune the dictionary.\n&quot;
	+ &quot;\t-W prunes after creating a full dictionary. You may not have enough memory for this approach.\n&quot;
	+ &quot;\t(default: no periodic pruning)&quot;,
	&quot;prune-rate&quot;, 1, &quot;-prune-rate &lt;rate as a percentage of dataset&gt;&quot;));

<span class="fc" id="L281">    result.addElement(new Option(</span>
	&quot;\tTransform the word frequencies into log(1+fij)\n&quot;+
	&quot;\twhere fij is the frequency of word i in jth document(instance).\n&quot;,
	&quot;T&quot;, 0, &quot;-T&quot;));

<span class="fc" id="L286">    result.addElement(new Option(</span>
	&quot;\tTransform each word frequency into:\n&quot;+
	&quot;\tfij*log(num of Documents/num of documents containing word i)\n&quot;+
	&quot;\t  where fij if frequency of word i in jth document(instance)&quot;,
	&quot;I&quot;, 0, &quot;-I&quot;));

<span class="fc" id="L292">    result.addElement(new Option(</span>
	&quot;\tWhether to 0=not normalize/1=normalize all data/2=normalize test data only\n&quot; 
	+ &quot;\tto average length of training documents &quot;
	+ &quot;(default 0=don\'t normalize).&quot;,
	&quot;N&quot;, 1, &quot;-N&quot;));

<span class="fc" id="L298">    result.addElement(new Option(</span>
	&quot;\tConvert all tokens to lowercase before &quot;+
	&quot;adding to the dictionary.&quot;,
	&quot;L&quot;, 0, &quot;-L&quot;));

<span class="fc" id="L303">    result.addElement(new Option(</span>
	&quot;\tIgnore words that are in the stoplist.&quot;,
	&quot;S&quot;, 0, &quot;-S&quot;));

<span class="fc" id="L307">    result.addElement(new Option(</span>
	&quot;\tThe stemmering algorihtm (classname plus parameters) to use.&quot;,
	&quot;stemmer&quot;, 1, &quot;-stemmer &lt;spec&gt;&quot;));

<span class="fc" id="L311">    result.addElement(new Option(</span>
	&quot;\tThe minimum term frequency (default = 1).&quot;,
	&quot;M&quot;, 1, &quot;-M &lt;int&gt;&quot;));

<span class="fc" id="L315">    result.addElement(new Option(</span>
	&quot;\tIf this is set, the maximum number of words and the \n&quot;
	+ &quot;\tminimum term frequency is not enforced on a per-class \n&quot;
	+ &quot;\tbasis but based on the documents in all the classes \n&quot;
	+ &quot;\t(even if a class attribute is set).&quot;,
	&quot;O&quot;, 0, &quot;-O&quot;));

<span class="fc" id="L322">    result.addElement(new Option(</span>
	&quot;\tA file containing stopwords to override the default ones.\n&quot;
	+ &quot;\tUsing this option automatically sets the flag ('-S') to use the\n&quot;
	+ &quot;\tstoplist if the file exists.\n&quot;
	+ &quot;\tFormat: one stopword per line, lines starting with '#'\n&quot;
	+ &quot;\tare interpreted as comments and ignored.&quot;,
	&quot;stopwords&quot;, 1, &quot;-stopwords &lt;file&gt;&quot;));

<span class="fc" id="L330">    result.addElement(new Option(</span>
	&quot;\tThe tokenizing algorihtm (classname plus parameters) to use.\n&quot;
<span class="fc" id="L332">	+ &quot;\t(default: &quot; + WordTokenizer.class.getName() + &quot;)&quot;,</span>
	&quot;tokenizer&quot;, 1, &quot;-tokenizer &lt;spec&gt;&quot;));

<span class="fc" id="L335">    return result.elements();</span>
  }

  /**
   * Parses a given list of options. &lt;p/&gt;
   * 
         &lt;!-- options-start --&gt;
         * Valid options are: &lt;p/&gt;
         * 
         * &lt;pre&gt; -C
         *  Output word counts rather than boolean word presence.
         * &lt;/pre&gt;
         * 
         * &lt;pre&gt; -R &amp;lt;index1,index2-index4,...&amp;gt;
         *  Specify list of string attributes to convert to words (as weka Range).
         *  (default: select all string attributes)&lt;/pre&gt;
         * 
         * &lt;pre&gt; -V
         *  Invert matching sense of column indexes.&lt;/pre&gt;
         * 
         * &lt;pre&gt; -P &amp;lt;attribute name prefix&amp;gt;
         *  Specify a prefix for the created attribute names.
         *  (default: &quot;&quot;)&lt;/pre&gt;
         * 
         * &lt;pre&gt; -W &amp;lt;number of words to keep&amp;gt;
         *  Specify approximate number of word fields to create.
         *  Surplus words will be discarded..
         *  (default: 1000)&lt;/pre&gt;
         * 
         * &lt;pre&gt; -prune-rate &amp;lt;rate as a percentage of dataset&amp;gt;
         *  Specify the rate (e.g., every 10% of the input dataset) at which to periodically prune the dictionary.
         *  -W prunes after creating a full dictionary. You may not have enough memory for this approach.
         *  (default: no periodic pruning)&lt;/pre&gt;
         * 
         * &lt;pre&gt; -T
         *  Transform the word frequencies into log(1+fij)
         *  where fij is the frequency of word i in jth document(instance).
         * &lt;/pre&gt;
         * 
         * &lt;pre&gt; -I
         *  Transform each word frequency into:
         *  fij*log(num of Documents/num of documents containing word i)
         *    where fij if frequency of word i in jth document(instance)&lt;/pre&gt;
         * 
         * &lt;pre&gt; -N
         *  Whether to 0=not normalize/1=normalize all data/2=normalize test data only
         *  to average length of training documents (default 0=don't normalize).&lt;/pre&gt;
         * 
         * &lt;pre&gt; -L
         *  Convert all tokens to lowercase before adding to the dictionary.&lt;/pre&gt;
         * 
         * &lt;pre&gt; -S
         *  Ignore words that are in the stoplist.&lt;/pre&gt;
         * 
         * &lt;pre&gt; -stemmer &amp;lt;spec&amp;gt;
         *  The stemmering algorihtm (classname plus parameters) to use.&lt;/pre&gt;
         * 
         * &lt;pre&gt; -M &amp;lt;int&amp;gt;
         *  The minimum term frequency (default = 1).&lt;/pre&gt;
         * 
         * &lt;pre&gt; -O
         *  If this is set, the maximum number of words and the 
         *  minimum term frequency is not enforced on a per-class 
         *  basis but based on the documents in all the classes 
         *  (even if a class attribute is set).&lt;/pre&gt;
         * 
         * &lt;pre&gt; -stopwords &amp;lt;file&amp;gt;
         *  A file containing stopwords to override the default ones.
         *  Using this option automatically sets the flag ('-S') to use the
         *  stoplist if the file exists.
         *  Format: one stopword per line, lines starting with '#'
         *  are interpreted as comments and ignored.&lt;/pre&gt;
         * 
         * &lt;pre&gt; -tokenizer &amp;lt;spec&amp;gt;
         *  The tokenizing algorihtm (classname plus parameters) to use.
         *  (default: weka.core.tokenizers.WordTokenizer)&lt;/pre&gt;
         * 
         &lt;!-- options-end --&gt;
   *
   * @param options the list of options as an array of strings
   * @throws Exception if an option is not supported
   */
  public void setOptions(String[] options) throws Exception {
    String 	value;

<span class="fc" id="L420">    value = Utils.getOption('R', options);</span>
<span class="fc bfc" id="L421" title="All 2 branches covered.">    if (value.length() != 0)</span>
<span class="fc" id="L422">      setSelectedRange(value);</span>
    else
<span class="fc" id="L424">      setSelectedRange(&quot;first-last&quot;);</span>

<span class="fc" id="L426">    setInvertSelection(Utils.getFlag('V', options));</span>

<span class="fc" id="L428">    value = Utils.getOption('P', options);</span>
<span class="pc bpc" id="L429" title="1 of 2 branches missed.">    if (value.length() != 0)</span>
<span class="nc" id="L430">      setAttributeNamePrefix(value);</span>
    else
<span class="fc" id="L432">      setAttributeNamePrefix(&quot;&quot;);</span>

<span class="fc" id="L434">    value = Utils.getOption('W', options);</span>
<span class="fc bfc" id="L435" title="All 2 branches covered.">    if (value.length() != 0)</span>
<span class="fc" id="L436">      setWordsToKeep(Integer.valueOf(value).intValue());</span>
    else
<span class="fc" id="L438">      setWordsToKeep(1000);</span>

<span class="fc" id="L440">    value = Utils.getOption(&quot;prune-rate&quot;, options);</span>
<span class="fc bfc" id="L441" title="All 2 branches covered.">    if (value.length() &gt; 0)</span>
<span class="fc" id="L442">      setPeriodicPruning(Double.parseDouble(value));</span>
    else
<span class="fc" id="L444">      setPeriodicPruning(-1);</span>

<span class="fc" id="L446">    value = Utils.getOption('M', options);</span>
<span class="fc bfc" id="L447" title="All 2 branches covered.">    if (value.length() != 0)</span>
<span class="fc" id="L448">      setMinTermFreq(Integer.valueOf(value).intValue());</span>
    else
<span class="fc" id="L450">      setMinTermFreq(1);</span>

<span class="fc" id="L452">    setOutputWordCounts(Utils.getFlag('C', options));</span>

<span class="fc" id="L454">    setTFTransform(Utils.getFlag('T',  options));</span>

<span class="fc" id="L456">    setIDFTransform(Utils.getFlag('I',  options));</span>

<span class="fc" id="L458">    setDoNotOperateOnPerClassBasis(Utils.getFlag('O', options));</span>

<span class="fc" id="L460">    String nString = Utils.getOption('N', options);</span>
<span class="fc bfc" id="L461" title="All 2 branches covered.">    if (nString.length() != 0)</span>
<span class="fc" id="L462">      setNormalizeDocLength(new SelectedTag(Integer.parseInt(nString), TAGS_FILTER));</span>
    else
<span class="fc" id="L464">      setNormalizeDocLength(new SelectedTag(FILTER_NONE, TAGS_FILTER));</span>

<span class="fc" id="L466">    setLowerCaseTokens(Utils.getFlag('L', options));</span>

<span class="fc" id="L468">    setUseStoplist(Utils.getFlag('S', options));</span>

<span class="fc" id="L470">    String stemmerString = Utils.getOption(&quot;stemmer&quot;, options);</span>
<span class="fc bfc" id="L471" title="All 2 branches covered.">    if (stemmerString.length() == 0) {</span>
<span class="fc" id="L472">      setStemmer(null);</span>
    }
    else {
<span class="fc" id="L475">      String[] stemmerSpec = Utils.splitOptions(stemmerString);</span>
<span class="pc bpc" id="L476" title="1 of 2 branches missed.">      if (stemmerSpec.length == 0)</span>
<span class="nc" id="L477">	throw new Exception(&quot;Invalid stemmer specification string&quot;);</span>
<span class="fc" id="L478">      String stemmerName = stemmerSpec[0];</span>
<span class="fc" id="L479">      stemmerSpec[0] = &quot;&quot;;</span>
<span class="fc" id="L480">      Stemmer stemmer = (Stemmer) Class.forName(stemmerName).newInstance();</span>
<span class="pc bpc" id="L481" title="1 of 2 branches missed.">      if (stemmer instanceof OptionHandler)</span>
<span class="nc" id="L482">	((OptionHandler) stemmer).setOptions(stemmerSpec);</span>
<span class="fc" id="L483">      setStemmer(stemmer);</span>
    }

<span class="fc" id="L486">    value = Utils.getOption(&quot;stopwords&quot;, options);</span>
<span class="pc bpc" id="L487" title="1 of 2 branches missed.">    if (value.length() != 0)</span>
<span class="nc" id="L488">      setStopwords(new File(value));</span>
    else
<span class="fc" id="L490">      setStopwords(null);</span>

<span class="fc" id="L492">    String tokenizerString = Utils.getOption(&quot;tokenizer&quot;, options);</span>
<span class="fc bfc" id="L493" title="All 2 branches covered.">    if (tokenizerString.length() == 0) {</span>
<span class="fc" id="L494">      setTokenizer(new WordTokenizer());</span>
    }
    else {
<span class="fc" id="L497">      String[] tokenizerSpec = Utils.splitOptions(tokenizerString);</span>
<span class="pc bpc" id="L498" title="1 of 2 branches missed.">      if (tokenizerSpec.length == 0)</span>
<span class="nc" id="L499">	throw new Exception(&quot;Invalid tokenizer specification string&quot;);</span>
<span class="fc" id="L500">      String tokenizerName = tokenizerSpec[0];</span>
<span class="fc" id="L501">      tokenizerSpec[0] = &quot;&quot;;</span>
<span class="fc" id="L502">      Tokenizer tokenizer = (Tokenizer) Class.forName(tokenizerName).newInstance();</span>
<span class="pc bpc" id="L503" title="1 of 2 branches missed.">      if (tokenizer instanceof OptionHandler)</span>
<span class="fc" id="L504">	((OptionHandler) tokenizer).setOptions(tokenizerSpec);</span>
<span class="fc" id="L505">      setTokenizer(tokenizer);</span>
    }
<span class="fc" id="L507">  }</span>

  /**
   * Gets the current settings of the filter.
   *
   * @return an array of strings suitable for passing to setOptions
   */
  public String[] getOptions() {
    Vector        result;

<span class="fc" id="L517">    result = new Vector();</span>

<span class="fc" id="L519">    result.add(&quot;-R&quot;); </span>
<span class="fc" id="L520">    result.add(getSelectedRange().getRanges());</span>

<span class="pc bpc" id="L522" title="1 of 2 branches missed.">    if (getInvertSelection())</span>
<span class="nc" id="L523">      result.add(&quot;-V&quot;);</span>

<span class="pc bpc" id="L525" title="1 of 2 branches missed.">    if (!&quot;&quot;.equals(getAttributeNamePrefix())) {</span>
<span class="nc" id="L526">      result.add(&quot;-P&quot;); </span>
<span class="nc" id="L527">      result.add(getAttributeNamePrefix());</span>
    }

<span class="fc" id="L530">    result.add(&quot;-W&quot;); </span>
<span class="fc" id="L531">    result.add(String.valueOf(getWordsToKeep()));</span>

<span class="fc" id="L533">    result.add(&quot;-prune-rate&quot;); </span>
<span class="fc" id="L534">    result.add(String.valueOf(getPeriodicPruning()));</span>

<span class="pc bpc" id="L536" title="1 of 2 branches missed.">    if (getOutputWordCounts())</span>
<span class="nc" id="L537">      result.add(&quot;-C&quot;);</span>

<span class="pc bpc" id="L539" title="1 of 2 branches missed.">    if (getTFTransform())</span>
<span class="nc" id="L540">      result.add(&quot;-T&quot;);</span>

<span class="pc bpc" id="L542" title="1 of 2 branches missed.">    if (getIDFTransform())</span>
<span class="nc" id="L543">      result.add(&quot;-I&quot;);</span>

<span class="fc" id="L545">    result.add(&quot;-N&quot;); </span>
<span class="fc" id="L546">    result.add(&quot;&quot; + m_filterType);</span>

<span class="pc bpc" id="L548" title="1 of 2 branches missed.">    if (getLowerCaseTokens())</span>
<span class="nc" id="L549">      result.add(&quot;-L&quot;);</span>

<span class="pc bpc" id="L551" title="1 of 2 branches missed.">    if (getUseStoplist())</span>
<span class="nc" id="L552">      result.add(&quot;-S&quot;);</span>

<span class="pc bpc" id="L554" title="1 of 2 branches missed.">    if (getStemmer() != null) {</span>
<span class="fc" id="L555">      result.add(&quot;-stemmer&quot;);</span>
<span class="fc" id="L556">      String spec = getStemmer().getClass().getName();</span>
<span class="pc bpc" id="L557" title="1 of 2 branches missed.">      if (getStemmer() instanceof OptionHandler)</span>
<span class="nc" id="L558">	spec += &quot; &quot; + Utils.joinOptions(</span>
<span class="nc" id="L559">	    ((OptionHandler) getStemmer()).getOptions());</span>
<span class="fc" id="L560">      result.add(spec.trim());</span>
    }

<span class="fc" id="L563">    result.add(&quot;-M&quot;); </span>
<span class="fc" id="L564">    result.add(String.valueOf(getMinTermFreq()));</span>

<span class="pc bpc" id="L566" title="1 of 2 branches missed.">    if (getDoNotOperateOnPerClassBasis())</span>
<span class="nc" id="L567">      result.add(&quot;-O&quot;);</span>

<span class="pc bpc" id="L569" title="1 of 2 branches missed.">    if (!getStopwords().isDirectory()) {</span>
<span class="nc" id="L570">      result.add(&quot;-stopwords&quot;);</span>
<span class="nc" id="L571">      result.add(getStopwords().getAbsolutePath());</span>
    }

<span class="fc" id="L574">    result.add(&quot;-tokenizer&quot;);</span>
<span class="fc" id="L575">    String spec = getTokenizer().getClass().getName();</span>
<span class="pc bpc" id="L576" title="1 of 2 branches missed.">    if (getTokenizer() instanceof OptionHandler)</span>
<span class="fc" id="L577">      spec += &quot; &quot; + Utils.joinOptions(</span>
<span class="fc" id="L578">	  ((OptionHandler) getTokenizer()).getOptions());</span>
<span class="fc" id="L579">    result.add(spec.trim());</span>

<span class="fc" id="L581">    return (String[]) result.toArray(new String[result.size()]);</span>
  }

  /**
   * Constructor that allows specification of the target number of words
   * in the output.
   *
   * @param wordsToKeep the number of words in the output vector (per class
   * if assigned).
   */
<span class="nc" id="L591">  public StringToWordVector(int wordsToKeep) {</span>
<span class="nc" id="L592">    m_WordsToKeep = wordsToKeep;</span>
<span class="nc" id="L593">  }</span>

  /** 
   * Used to store word counts for dictionary selection based on 
   * a threshold.
   */
  private class Count 
  implements Serializable, RevisionHandler {

    /** for serialization. */
    static final long serialVersionUID = 2157223818584474321L;

    /** the counts. */
    public int count, docCount;

    /**
     * the constructor.
     * 
     * @param c the count
     */
<span class="fc" id="L613">    public Count(int c) { </span>
<span class="fc" id="L614">      count = c; </span>
<span class="fc" id="L615">    }</span>
    
    /**
     * Returns the revision string.
     * 
     * @return		the revision
     */
    public String getRevision() {
<span class="nc" id="L623">      return RevisionUtils.extract(&quot;$Revision: 9565 $&quot;);</span>
    }
  }

  /** 
   * Returns the Capabilities of this filter.
   *
   * @return            the capabilities of this object
   * @see               Capabilities
   */
  public Capabilities getCapabilities() {
<span class="fc" id="L634">    Capabilities result = super.getCapabilities();</span>
<span class="fc" id="L635">    result.disableAll();</span>

    // attributes
<span class="fc" id="L638">    result.enableAllAttributes();</span>
<span class="fc" id="L639">    result.enable(Capability.MISSING_VALUES);</span>

    // class
<span class="fc" id="L642">    result.enableAllClasses();</span>
<span class="fc" id="L643">    result.enable(Capability.MISSING_CLASS_VALUES);</span>
<span class="fc" id="L644">    result.enable(Capability.NO_CLASS);</span>

<span class="fc" id="L646">    return result;</span>
  }

  /**
   * Sets the format of the input instances.
   *
   * @param instanceInfo an Instances object containing the input 
   * instance structure (any instances contained in the object are 
   * ignored - only the structure is required).
   * @return true if the outputFormat may be collected immediately
   * @throws Exception if the input format can't be set 
   * successfully
   */
  public boolean setInputFormat(Instances instanceInfo) 
  throws Exception {

<span class="fc" id="L662">    super.setInputFormat(instanceInfo);</span>
<span class="fc" id="L663">    m_SelectedRange.setUpper(instanceInfo.numAttributes() - 1);</span>
<span class="fc" id="L664">    m_AvgDocLength = -1;</span>
<span class="fc" id="L665">    m_NumInstances = -1;</span>
<span class="fc" id="L666">    return false;</span>
  }

  /**
   * Input an instance for filtering. Filter requires all
   * training instances be read before producing output.
   *
   * @param instance the input instance.
   * @return true if the filtered instance may now be
   * collected with output().
   * @throws IllegalStateException if no input structure has been defined.
   */
  public boolean input(Instance instance) throws Exception {

<span class="pc bpc" id="L680" title="1 of 2 branches missed.">    if (getInputFormat() == null) {</span>
<span class="nc" id="L681">      throw new IllegalStateException(&quot;No input instance format defined&quot;);</span>
    }
<span class="fc bfc" id="L683" title="All 2 branches covered.">    if (m_NewBatch) {</span>
<span class="fc" id="L684">      resetQueue();</span>
<span class="fc" id="L685">      m_NewBatch = false;</span>
    }
<span class="fc bfc" id="L687" title="All 2 branches covered.">    if (isFirstBatchDone()) {</span>
<span class="fc" id="L688">      FastVector fv = new FastVector();</span>
<span class="fc" id="L689">      int firstCopy = convertInstancewoDocNorm(instance, fv);</span>
<span class="fc" id="L690">      Instance inst = (Instance)fv.elementAt(0);</span>
<span class="pc bpc" id="L691" title="1 of 2 branches missed.">      if (m_filterType != FILTER_NONE) {</span>
<span class="nc" id="L692">	normalizeInstance(inst, firstCopy);</span>
      }
<span class="fc" id="L694">      push(inst);</span>
<span class="fc" id="L695">      return true;</span>
    } else {
<span class="fc" id="L697">      bufferInput(instance);</span>
<span class="fc" id="L698">      return false;</span>
    }
  }

  /**
   * Signify that this batch of input to the filter is finished. 
   * If the filter requires all instances prior to filtering,
   * output() may now be called to retrieve the filtered instances.
   *
   * @return true if there are instances pending output.
   * @throws IllegalStateException if no input structure has been defined.
   */
  public boolean batchFinished() throws Exception {

<span class="pc bpc" id="L712" title="1 of 2 branches missed.">    if (getInputFormat() == null) {</span>
<span class="nc" id="L713">      throw new IllegalStateException(&quot;No input instance format defined&quot;);</span>
    }

    // We only need to do something in this method
    // if the first batch hasn't been processed. Otherwise
    // input() has already done all the work.
<span class="fc bfc" id="L719" title="All 2 branches covered.">    if (!isFirstBatchDone()) {</span>
      
      // turn of per-class mode if the class is not nominal (or is all missing)!
<span class="fc bfc" id="L722" title="All 2 branches covered.">      if (getInputFormat().classIndex() &gt;= 0) {</span>
<span class="pc bpc" id="L723" title="1 of 2 branches missed.">        if (!getInputFormat().classAttribute().isNominal() || </span>
<span class="pc bpc" id="L724" title="1 of 2 branches missed.">            getInputFormat().attributeStats(getInputFormat().classIndex()).missingCount == getInputFormat().numInstances()) {</span>
<span class="nc" id="L725">          m_doNotOperateOnPerClassBasis = true;</span>
        }
      }

      // Determine the dictionary from the first batch (training data)
<span class="fc" id="L730">      determineDictionary();</span>

      // Convert all instances w/o normalization
<span class="fc" id="L733">      FastVector fv = new FastVector();</span>
<span class="fc" id="L734">      int firstCopy=0;</span>
<span class="fc bfc" id="L735" title="All 2 branches covered.">      for(int i=0; i &lt; m_NumInstances; i++) {</span>
<span class="fc" id="L736">	firstCopy = convertInstancewoDocNorm(getInputFormat().instance(i), fv);</span>
      }

      // Need to compute average document length if necessary
<span class="pc bpc" id="L740" title="1 of 2 branches missed.">      if (m_filterType != FILTER_NONE) {</span>
<span class="nc" id="L741">	m_AvgDocLength = 0;</span>
<span class="nc bnc" id="L742" title="All 2 branches missed.">	for(int i=0; i&lt;fv.size(); i++) {</span>
<span class="nc" id="L743">	  Instance inst = (Instance) fv.elementAt(i);</span>
<span class="nc" id="L744">	  double docLength = 0;</span>
<span class="nc bnc" id="L745" title="All 2 branches missed.">	  for(int j=0; j&lt;inst.numValues(); j++) {</span>
<span class="nc bnc" id="L746" title="All 2 branches missed.">	    if(inst.index(j)&gt;=firstCopy) {</span>
<span class="nc" id="L747">	      docLength += inst.valueSparse(j) * inst.valueSparse(j);</span>
	    }
	  }        
<span class="nc" id="L750">	  m_AvgDocLength += Math.sqrt(docLength);</span>
	}
<span class="nc" id="L752">	m_AvgDocLength /= m_NumInstances;</span>
      }

      // Perform normalization if necessary.
<span class="pc bpc" id="L756" title="1 of 2 branches missed.">      if (m_filterType == FILTER_NORMALIZE_ALL) {</span>
<span class="nc bnc" id="L757" title="All 2 branches missed.">	for(int i=0; i&lt;fv.size(); i++) {</span>
<span class="nc" id="L758">	  normalizeInstance((Instance) fv.elementAt(i), firstCopy);</span>
	}
      }

      // Push all instances into the output queue
<span class="fc bfc" id="L763" title="All 2 branches covered.">      for(int i=0; i&lt;fv.size(); i++) {</span>
<span class="fc" id="L764">	push((Instance) fv.elementAt(i));</span>
      }
    }

    // Flush the input
<span class="fc" id="L769">    flushInput();</span>

<span class="fc" id="L771">    m_NewBatch = true;</span>
<span class="fc" id="L772">    m_FirstBatchDone = true;</span>
<span class="fc bfc" id="L773" title="All 2 branches covered.">    return (numPendingOutput() != 0);</span>
  }

  /**
   * Returns a string describing this filter.
   * 
   * @return a description of the filter suitable for
   * displaying in the explorer/experimenter gui
   */  
  public String globalInfo() {
<span class="nc" id="L783">    return </span>
    &quot;Converts String attributes into a set of attributes representing &quot;
    + &quot;word occurrence (depending on the tokenizer) information from the &quot;
    + &quot;text contained in the strings. The set of words (attributes) is &quot;
    + &quot;determined by the first batch filtered (typically training data).&quot;;
  }  

  /**
   * Gets whether output instances contain 0 or 1 indicating word
   * presence, or word counts.
   *
   * @return true if word counts should be output.
   */
  public boolean getOutputWordCounts() {
<span class="fc" id="L797">    return m_OutputCounts;</span>
  }

  /**
   * Sets whether output instances contain 0 or 1 indicating word
   * presence, or word counts.
   *
   * @param outputWordCounts true if word counts should be output.
   */
  public void setOutputWordCounts(boolean outputWordCounts) {
<span class="fc" id="L807">    m_OutputCounts = outputWordCounts;</span>
<span class="fc" id="L808">  }</span>

  /**
   * Returns the tip text for this property.
   * 
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String outputWordCountsTipText() {
<span class="nc" id="L817">    return &quot;Output word counts rather than boolean 0 or 1&quot;+</span>
    &quot;(indicating presence or absence of a word).&quot;;
  }

  /**
   * Get the value of m_SelectedRange.
   *
   * @return Value of m_SelectedRange.
   */
  public Range getSelectedRange() {
<span class="fc" id="L827">    return m_SelectedRange;</span>
  }

  /**
   * Set the value of m_SelectedRange.
   *
   * @param newSelectedRange Value to assign to m_SelectedRange.
   */
  public void setSelectedRange(String newSelectedRange) {
<span class="fc" id="L836">    m_SelectedRange = new Range(newSelectedRange);</span>
<span class="fc" id="L837">  }</span>

  /**
   * Returns the tip text for this property.
   *
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String attributeIndicesTipText() {
<span class="nc" id="L846">    return &quot;Specify range of attributes to act on.&quot;</span>
    + &quot; This is a comma separated list of attribute indices, with&quot;
    + &quot; \&quot;first\&quot; and \&quot;last\&quot; valid values. Specify an inclusive&quot;
    + &quot; range with \&quot;-\&quot;. E.g: \&quot;first-3,5,6-10,last\&quot;.&quot;;
  }

  /**
   * Gets the current range selection.
   *
   * @return a string containing a comma separated list of ranges
   */
  public String getAttributeIndices() {
<span class="nc" id="L858">    return m_SelectedRange.getRanges();</span>
  }

  /**
   * Sets which attributes are to be worked on.
   *
   * @param rangeList a string representing the list of attributes. Since
   * the string will typically come from a user, attributes are indexed from
   * 1. &lt;br&gt;
   * eg: first-3,5,6-last
   * @throws IllegalArgumentException if an invalid range list is supplied 
   */
  public void setAttributeIndices(String rangeList) {
<span class="nc" id="L871">    m_SelectedRange.setRanges(rangeList);</span>
<span class="nc" id="L872">  }</span>

  /**
   * Sets which attributes are to be processed.
   *
   * @param attributes an array containing indexes of attributes to process.
   * Since the array will typically come from a program, attributes are indexed
   * from 0.
   * @throws IllegalArgumentException if an invalid set of ranges
   * is supplied 
   */
  public void setAttributeIndicesArray(int[] attributes) {
<span class="nc" id="L884">    setAttributeIndices(Range.indicesToRangeList(attributes));</span>
<span class="nc" id="L885">  }</span>

  /**
   * Returns the tip text for this property.
   *
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String invertSelectionTipText() {
<span class="nc" id="L894">    return &quot;Set attribute selection mode. If false, only selected&quot;</span>
    + &quot; attributes in the range will be worked on; if&quot;
    + &quot; true, only non-selected attributes will be processed.&quot;;
  }

  /**
   * Gets whether the supplied columns are to be processed or skipped.
   *
   * @return true if the supplied columns will be kept
   */
  public boolean getInvertSelection() {
<span class="fc" id="L905">    return m_SelectedRange.getInvert();</span>
  }

  /**
   * Sets whether selected columns should be processed or skipped.
   *
   * @param invert the new invert setting
   */
  public void setInvertSelection(boolean invert) {
<span class="fc" id="L914">    m_SelectedRange.setInvert(invert);</span>
<span class="fc" id="L915">  }</span>

  /**
   * Get the attribute name prefix.
   *
   * @return The current attribute name prefix.
   */
  public String getAttributeNamePrefix() {
<span class="fc" id="L923">    return m_Prefix;</span>
  }

  /**
   * Set the attribute name prefix.
   *
   * @param newPrefix String to use as the attribute name prefix.
   */
  public void setAttributeNamePrefix(String newPrefix) {
<span class="fc" id="L932">    m_Prefix = newPrefix;</span>
<span class="fc" id="L933">  }</span>

  /**
   * Returns the tip text for this property.
   * 
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String attributeNamePrefixTipText() {
<span class="nc" id="L942">    return &quot;Prefix for the created attribute names. &quot;+</span>
    &quot;(default: \&quot;\&quot;)&quot;;
  }

  /**
   * Gets the number of words (per class if there is a class attribute
   * assigned) to attempt to keep.
   *
   * @return the target number of words in the output vector (per class if
   * assigned).
   */
  public int getWordsToKeep() {
<span class="fc" id="L954">    return m_WordsToKeep;</span>
  }

  /**
   * Sets the number of words (per class if there is a class attribute
   * assigned) to attempt to keep.
   *
   * @param newWordsToKeep the target number of words in the output 
   * vector (per class if assigned).
   */
  public void setWordsToKeep(int newWordsToKeep) {
<span class="fc" id="L965">    m_WordsToKeep = newWordsToKeep;</span>
<span class="fc" id="L966">  }</span>

  /**
   * Returns the tip text for this property.
   * 
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String wordsToKeepTipText() {
<span class="nc" id="L975">    return &quot;The number of words (per class if there is a class attribute &quot;+</span>
    &quot;assigned) to attempt to keep.&quot;;
  }

  /**
   * Gets the rate at which the dictionary is periodically pruned, as a 
   * percentage of the dataset size.
   *
   * @return the rate at which the dictionary is periodically pruned
   */
  public double getPeriodicPruning() {
<span class="fc" id="L986">    return m_PeriodicPruningRate;</span>
  }

  /**
   * Sets the rate at which the dictionary is periodically pruned, as a 
   * percentage of the dataset size.
   *
   * @param newPeriodicPruning the rate at which the dictionary is periodically pruned
   */
  public void setPeriodicPruning(double newPeriodicPruning) {
<span class="fc" id="L996">    m_PeriodicPruningRate = newPeriodicPruning;</span>
<span class="fc" id="L997">  }</span>

  /**
   * Returns the tip text for this property.
   * 
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String periodicPruningTipText() {
<span class="nc" id="L1006">    return &quot;Specify the rate (x% of the input dataset) at which to periodically prune the dictionary. &quot;</span>
    + &quot;wordsToKeep prunes after creating a full dictionary. You may not have enough &quot;
    + &quot;memory for this approach.&quot;;
  }

  /** Gets whether if the word frequencies should be transformed into
   *  log(1+fij) where fij is the frequency of word i in document(instance) j.
   *
   * @return true if word frequencies are to be transformed.
   */
  public boolean getTFTransform() {
<span class="fc" id="L1017">    return this.m_TFTransform;</span>
  }

  /** Sets whether if the word frequencies should be transformed into
   *  log(1+fij) where fij is the frequency of word i in document(instance) j.
   *
   * @param TFTransform true if word frequencies are to be transformed.
   */
  public void setTFTransform(boolean TFTransform) {
<span class="fc" id="L1026">    this.m_TFTransform = TFTransform;</span>
<span class="fc" id="L1027">  }</span>

  /**
   * Returns the tip text for this property.
   * 
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String TFTransformTipText() {
<span class="nc" id="L1036">    return &quot;Sets whether if the word frequencies should be transformed into:\n &quot;+</span>
    &quot;   log(1+fij) \n&quot;+
    &quot;       where fij is the frequency of word i in document (instance) j.&quot;;
  }

  /** Sets whether if the word frequencies in a document should be transformed
   * into: &lt;br&gt;
   * fij*log(num of Docs/num of Docs with word i) &lt;br&gt;
   *      where fij is the frequency of word i in document(instance) j.
   *
   * @return true if the word frequencies are to be transformed.
   */
  public boolean getIDFTransform() {
<span class="fc" id="L1049">    return this.m_IDFTransform;</span>
  }

  /** Sets whether if the word frequencies in a document should be transformed
   * into: &lt;br&gt;
   * fij*log(num of Docs/num of Docs with word i) &lt;br&gt;
   *      where fij is the frequency of word i in document(instance) j.
   *
   * @param IDFTransform true if the word frequecies are to be transformed
   */
  public void setIDFTransform(boolean IDFTransform) {
<span class="fc" id="L1060">    this.m_IDFTransform = IDFTransform;</span>
<span class="fc" id="L1061">  }</span>

  /**
   * Returns the tip text for this property.
   * 
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String IDFTransformTipText() {
<span class="nc" id="L1070">    return &quot;Sets whether if the word frequencies in a document should be &quot;+</span>
    &quot;transformed into: \n&quot;+
    &quot;   fij*log(num of Docs/num of Docs with word i) \n&quot;+
    &quot;      where fij is the frequency of word i in document (instance) j.&quot;;
  }


  /** Gets whether if the word frequencies for a document (instance) should
   *  be normalized or not.
   *
   * @return true if word frequencies are to be normalized.
   */
  public SelectedTag getNormalizeDocLength() {

<span class="nc" id="L1084">    return new SelectedTag(m_filterType, TAGS_FILTER);</span>
  }

  /** Sets whether if the word frequencies for a document (instance) should
   *  be normalized or not.
   *
   * @param newType the new type.
   */
  public void setNormalizeDocLength(SelectedTag newType) {

<span class="pc bpc" id="L1094" title="1 of 2 branches missed.">    if (newType.getTags() == TAGS_FILTER) {</span>
<span class="fc" id="L1095">      m_filterType = newType.getSelectedTag().getID();</span>
    }
<span class="fc" id="L1097">  }</span>

  /**
   * Returns the tip text for this property.
   *
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String normalizeDocLengthTipText() {
<span class="nc" id="L1106">    return &quot;Sets whether if the word frequencies for a document (instance) &quot;+</span>
    &quot;should be normalized or not.&quot;;
  }

  /** Gets whether if the tokens are to be downcased or not.
   *
   * @return true if the tokens are to be downcased.
   */
  public boolean getLowerCaseTokens() {
<span class="fc" id="L1115">    return this.m_lowerCaseTokens;</span>
  }

  /** Sets whether if the tokens are to be downcased or not. (Doesn't affect
   * non-alphabetic characters in tokens).
   *
   * @param downCaseTokens should be true if only lower case tokens are 
   * to be formed.
   */
  public void setLowerCaseTokens(boolean downCaseTokens) {
<span class="fc" id="L1125">    this.m_lowerCaseTokens = downCaseTokens;</span>
<span class="fc" id="L1126">  }</span>

  /**
   * Returns the tip text for this property.
   *
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String doNotOperateOnPerClassBasisTipText() {
<span class="nc" id="L1135">    return &quot;If this is set, the maximum number of words and the &quot;</span>
    + &quot;minimum term frequency is not enforced on a per-class &quot;
    + &quot;basis but based on the documents in all the classes &quot;
    +  &quot;(even if a class attribute is set).&quot;;
  }

  /**
   * Get the DoNotOperateOnPerClassBasis value.
   * @return the DoNotOperateOnPerClassBasis value.
   */
  public boolean getDoNotOperateOnPerClassBasis() {
<span class="fc" id="L1146">    return m_doNotOperateOnPerClassBasis;</span>
  }

  /**
   * Set the DoNotOperateOnPerClassBasis value.
   * @param newDoNotOperateOnPerClassBasis The new DoNotOperateOnPerClassBasis value.
   */
  public void setDoNotOperateOnPerClassBasis(boolean newDoNotOperateOnPerClassBasis) {
<span class="fc" id="L1154">    this.m_doNotOperateOnPerClassBasis = newDoNotOperateOnPerClassBasis;</span>
<span class="fc" id="L1155">  }</span>

  /**
   * Returns the tip text for this property.
   *
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String minTermFreqTipText() {
<span class="nc" id="L1164">    return &quot;Sets the minimum term frequency. This is enforced &quot;</span>
    + &quot;on a per-class basis.&quot;;
  }

  /**
   * Get the MinTermFreq value.
   * @return the MinTermFreq value.
   */
  public int getMinTermFreq() {
<span class="fc" id="L1173">    return m_minTermFreq;</span>
  }

  /**
   * Set the MinTermFreq value.
   * @param newMinTermFreq The new MinTermFreq value.
   */
  public void setMinTermFreq(int newMinTermFreq) {
<span class="fc" id="L1181">    this.m_minTermFreq = newMinTermFreq;</span>
<span class="fc" id="L1182">  }</span>

  /**
   * Returns the tip text for this property.
   *
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String lowerCaseTokensTipText() {
<span class="nc" id="L1191">    return &quot;If set then all the word tokens are converted to lower case &quot;+</span>
    &quot;before being added to the dictionary.&quot;;
  }

  /** Gets whether if the words on the stoplist are to be ignored (The stoplist
   *  is in weka.core.StopWords).
   *
   * @return true if the words on the stoplist are to be ignored.
   */
  public boolean getUseStoplist() {
<span class="fc" id="L1201">    return m_useStoplist;</span>
  }  

  /** Sets whether if the words that are on a stoplist are to be ignored (The
   * stop list is in weka.core.StopWords).
   *
   * @param useStoplist true if the tokens that are on a stoplist are to be 
   * ignored.
   */
  public void setUseStoplist(boolean useStoplist) {
<span class="fc" id="L1211">    m_useStoplist = useStoplist;</span>
<span class="fc" id="L1212">  }  </span>

  /**
   * Returns the tip text for this property.
   *
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String useStoplistTipText() {
<span class="nc" id="L1221">    return &quot;Ignores all the words that are on the stoplist, if set to true.&quot;;</span>
  } 

  /**
   * the stemming algorithm to use, null means no stemming at all (i.e., the
   * NullStemmer is used).
   *
   * @param value     the configured stemming algorithm, or null
   * @see             NullStemmer
   */
  public void setStemmer(Stemmer value) {
<span class="fc bfc" id="L1232" title="All 2 branches covered.">    if (value != null)</span>
<span class="fc" id="L1233">      m_Stemmer = value;</span>
    else
<span class="fc" id="L1235">      m_Stemmer = new NullStemmer();</span>
<span class="fc" id="L1236">  }</span>

  /**
   * Returns the current stemming algorithm, null if none is used.
   *
   * @return          the current stemming algorithm, null if none set
   */
  public Stemmer getStemmer() {
<span class="fc" id="L1244">    return m_Stemmer;</span>
  }

  /**
   * Returns the tip text for this property.
   *
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String stemmerTipText() {
<span class="nc" id="L1254">    return &quot;The stemming algorithm to use on the words.&quot;;</span>
  }

  /**
   * sets the file containing the stopwords, null or a directory unset the
   * stopwords. If the file exists, it automatically turns on the flag to
   * use the stoplist.
   *
   * @param value     the file containing the stopwords
   */
  public void setStopwords(File value) {
<span class="pc bpc" id="L1265" title="1 of 2 branches missed.">    if (value == null)</span>
<span class="fc" id="L1266">      value = new File(System.getProperty(&quot;user.dir&quot;));</span>

<span class="fc" id="L1268">    m_Stopwords = value;</span>
<span class="pc bpc" id="L1269" title="2 of 4 branches missed.">    if (value.exists() &amp;&amp; value.isFile())</span>
<span class="nc" id="L1270">      setUseStoplist(true);</span>
<span class="fc" id="L1271">  }</span>

  /**
   * returns the file used for obtaining the stopwords, if the file represents
   * a directory then the default ones are used.
   *
   * @return          the file containing the stopwords
   */
  public File getStopwords() {
<span class="fc" id="L1280">    return m_Stopwords;</span>
  }

  /**
   * Returns the tip text for this property.
   *
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String stopwordsTipText() {
<span class="nc" id="L1290">    return &quot;The file containing the stopwords (if this is a directory then the default ones are used).&quot;;</span>
  }

  /**
   * the tokenizer algorithm to use.
   *
   * @param value     the configured tokenizing algorithm
   */
  public void setTokenizer(Tokenizer value) {
<span class="fc" id="L1299">    m_Tokenizer = value;</span>
<span class="fc" id="L1300">  }</span>

  /**
   * Returns the current tokenizer algorithm.
   *
   * @return          the current tokenizer algorithm
   */
  public Tokenizer getTokenizer() {
<span class="fc" id="L1308">    return m_Tokenizer;</span>
  }

  /**
   * Returns the tip text for this property.
   *
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String tokenizerTipText() {
<span class="nc" id="L1318">    return &quot;The tokenizing algorithm to use on the strings.&quot;;</span>
  }

  /**
   * sorts an array.
   * 
   * @param array the array to sort
   */
  private static void sortArray(int [] array) {

<span class="fc" id="L1328">    int i, j, h, N = array.length - 1;</span>

<span class="fc bfc" id="L1330" title="All 2 branches covered.">    for (h = 1; h &lt;= N / 9; h = 3 * h + 1); </span>

<span class="fc bfc" id="L1332" title="All 2 branches covered.">    for (; h &gt; 0; h /= 3) {</span>
<span class="fc bfc" id="L1333" title="All 2 branches covered.">      for (i = h + 1; i &lt;= N; i++) { </span>
<span class="fc" id="L1334">	int v = array[i]; </span>
<span class="fc" id="L1335">	j = i; </span>
<span class="fc bfc" id="L1336" title="All 4 branches covered.">	while (j &gt; h &amp;&amp; array[j - h] &gt; v ) { </span>
<span class="fc" id="L1337">	  array[j] = array[j - h]; </span>
<span class="fc" id="L1338">	  j -= h; </span>
	} 
<span class="fc" id="L1340">	array[j] = v; </span>
      } 
    }
<span class="fc" id="L1343">  }</span>

  /**
   * determines the selected range.
   */
  private void determineSelectedRange() {

<span class="fc" id="L1350">    Instances inputFormat = getInputFormat();</span>

    // Calculate the default set of fields to convert
<span class="pc bpc" id="L1353" title="1 of 2 branches missed.">    if (m_SelectedRange == null) {</span>
<span class="nc" id="L1354">      StringBuffer fields = new StringBuffer();</span>
<span class="nc bnc" id="L1355" title="All 2 branches missed.">      for (int j = 0; j &lt; inputFormat.numAttributes(); j++) { </span>
<span class="nc bnc" id="L1356" title="All 2 branches missed.">	if (inputFormat.attribute(j).type() == Attribute.STRING)</span>
<span class="nc" id="L1357">	  fields.append((j + 1) + &quot;,&quot;);</span>
      }
<span class="nc" id="L1359">      m_SelectedRange = new Range(fields.toString());</span>
    }
<span class="fc" id="L1361">    m_SelectedRange.setUpper(inputFormat.numAttributes() - 1);</span>

    // Prevent the user from converting non-string fields
<span class="fc" id="L1364">    StringBuffer fields = new StringBuffer();</span>
<span class="fc bfc" id="L1365" title="All 2 branches covered.">    for (int j = 0; j &lt; inputFormat.numAttributes(); j++) { </span>
<span class="fc bfc" id="L1366" title="All 2 branches covered.">      if (m_SelectedRange.isInRange(j) </span>
<span class="fc bfc" id="L1367" title="All 2 branches covered.">	  &amp;&amp; inputFormat.attribute(j).type() == Attribute.STRING)</span>
<span class="fc" id="L1368">	fields.append((j + 1) + &quot;,&quot;);</span>
    }
<span class="fc" id="L1370">    m_SelectedRange.setRanges(fields.toString());</span>
<span class="fc" id="L1371">    m_SelectedRange.setUpper(inputFormat.numAttributes() - 1);</span>

    // System.err.println(&quot;Selected Range: &quot; + getSelectedRange().getRanges()); 
<span class="fc" id="L1374">  }</span>

  /**
   * determines the dictionary.
   */
  private void determineDictionary() {
    // initialize stopwords
<span class="fc" id="L1381">    Stopwords stopwords = new Stopwords();</span>
<span class="pc bpc" id="L1382" title="1 of 2 branches missed.">    if (getUseStoplist()) {</span>
      try {
<span class="nc bnc" id="L1384" title="All 4 branches missed.">	if (getStopwords().exists() &amp;&amp; !getStopwords().isDirectory())</span>
<span class="nc" id="L1385">	  stopwords.read(getStopwords());</span>
      }
<span class="nc" id="L1387">      catch (Exception e) {</span>
<span class="nc" id="L1388">	e.printStackTrace();</span>
<span class="nc" id="L1389">      }</span>
    }

    // Operate on a per-class basis if class attribute is set
<span class="fc" id="L1393">    int classInd = getInputFormat().classIndex();</span>
<span class="fc" id="L1394">    int values = 1;</span>
<span class="pc bpc" id="L1395" title="1 of 4 branches missed.">    if (!m_doNotOperateOnPerClassBasis &amp;&amp; (classInd != -1)) {</span>
<span class="fc" id="L1396">      values = getInputFormat().attribute(classInd).numValues();</span>
    }

    //TreeMap dictionaryArr [] = new TreeMap[values];
<span class="fc" id="L1400">    TreeMap [] dictionaryArr = new TreeMap[values];</span>
<span class="fc bfc" id="L1401" title="All 2 branches covered.">    for (int i = 0; i &lt; values; i++) {</span>
<span class="fc" id="L1402">      dictionaryArr[i] = new TreeMap();</span>
    }

    // Make sure we know which fields to convert
<span class="fc" id="L1406">    determineSelectedRange();</span>

    // Tokenize all training text into an orderedMap of &quot;words&quot;.
<span class="fc" id="L1409">    long pruneRate = </span>
<span class="fc" id="L1410">      Math.round((m_PeriodicPruningRate/100.0)*getInputFormat().numInstances());</span>
<span class="fc bfc" id="L1411" title="All 2 branches covered.">    for (int i = 0; i &lt; getInputFormat().numInstances(); i++) {</span>
<span class="fc" id="L1412">      Instance instance = getInputFormat().instance(i);</span>
<span class="fc" id="L1413">      int vInd = 0;</span>
<span class="pc bpc" id="L1414" title="1 of 4 branches missed.">      if (!m_doNotOperateOnPerClassBasis &amp;&amp; (classInd != -1)) {</span>
<span class="fc" id="L1415">	vInd = (int)instance.classValue();</span>
      }

      // Iterate through all relevant string attributes of the current instance
<span class="fc" id="L1419">      Hashtable h = new Hashtable();</span>
<span class="fc bfc" id="L1420" title="All 2 branches covered.">      for (int j = 0; j &lt; instance.numAttributes(); j++) { </span>
<span class="fc bfc" id="L1421" title="All 4 branches covered.">	if (m_SelectedRange.isInRange(j) &amp;&amp; (instance.isMissing(j) == false)) {</span>

	  // Get tokenizer
<span class="fc" id="L1424">	  m_Tokenizer.tokenize(instance.stringValue(j));</span>

	  // Iterate through tokens, perform stemming, and remove stopwords
	  // (if required)
<span class="fc bfc" id="L1428" title="All 2 branches covered.">	  while (m_Tokenizer.hasMoreElements()) {</span>
<span class="fc" id="L1429">	    String word = ((String)m_Tokenizer.nextElement()).intern();</span>

<span class="pc bpc" id="L1431" title="1 of 2 branches missed.">	    if(this.m_lowerCaseTokens==true)</span>
<span class="nc" id="L1432">	      word = word.toLowerCase();</span>

<span class="fc" id="L1434">	    word = m_Stemmer.stem(word);</span>

<span class="pc bpc" id="L1436" title="1 of 2 branches missed.">	    if(this.m_useStoplist==true)</span>
<span class="nc bnc" id="L1437" title="All 2 branches missed.">	      if(stopwords.is(word))</span>
<span class="nc" id="L1438">		continue;</span>

<span class="pc bpc" id="L1440" title="1 of 2 branches missed.">	    if(!(h.containsKey(word)))</span>
<span class="fc" id="L1441">	      h.put(word, new Integer(0));</span>

<span class="fc" id="L1443">	    Count count = (Count)dictionaryArr[vInd].get(word);</span>
<span class="fc bfc" id="L1444" title="All 2 branches covered.">	    if (count == null) {</span>
<span class="fc" id="L1445">	      dictionaryArr[vInd].put(word, new Count(1));</span>
	    } else {
<span class="fc" id="L1447">	      count.count++;                </span>
	    }
<span class="fc" id="L1449">	  }          </span>
	}
      }

      //updating the docCount for the words that have occurred in this
      //instance(document).
<span class="fc" id="L1455">      Enumeration e = h.keys();</span>
<span class="fc bfc" id="L1456" title="All 2 branches covered.">      while(e.hasMoreElements()) {</span>
<span class="fc" id="L1457">	String word = (String) e.nextElement();</span>
<span class="fc" id="L1458">	Count c = (Count)dictionaryArr[vInd].get(word);</span>
<span class="pc bpc" id="L1459" title="1 of 2 branches missed.">	if(c!=null) {</span>
<span class="fc" id="L1460">	  c.docCount++;</span>
	} else 
<span class="nc" id="L1462">	  System.err.println(&quot;Warning: A word should definitely be in the &quot;+</span>
	      &quot;dictionary.Please check the code&quot;);
<span class="fc" id="L1464">      }</span>


<span class="pc bpc" id="L1467" title="1 of 2 branches missed.">      if (pruneRate &gt; 0) {</span>
<span class="nc bnc" id="L1468" title="All 4 branches missed.">	if (i % pruneRate == 0 &amp;&amp; i &gt; 0) {</span>
<span class="nc bnc" id="L1469" title="All 2 branches missed.">	  for (int z = 0; z &lt; values; z++) {</span>
<span class="nc" id="L1470">	    Vector d = new Vector(1000);</span>
<span class="nc" id="L1471">	    Iterator it = dictionaryArr[z].keySet().iterator();</span>
<span class="nc bnc" id="L1472" title="All 2 branches missed.">	    while (it.hasNext()) {</span>
<span class="nc" id="L1473">	      String word = (String)it.next();</span>
<span class="nc" id="L1474">	      Count count = (Count)dictionaryArr[z].get(word);</span>
<span class="nc bnc" id="L1475" title="All 2 branches missed.">	      if (count.count &lt;= 1) { d.add(word); }</span>
<span class="nc" id="L1476">	    }</span>
<span class="nc" id="L1477">	    Iterator iter = d.iterator();</span>
<span class="nc bnc" id="L1478" title="All 2 branches missed.">	    while(iter.hasNext()) {</span>
<span class="nc" id="L1479">	      String word = (String)iter.next();</span>
<span class="nc" id="L1480">	      dictionaryArr[z].remove(word);</span>
<span class="nc" id="L1481">	    }</span>
	  }
	}
      }
    }

    // Figure out the minimum required word frequency
<span class="fc" id="L1488">    int totalsize = 0;</span>
<span class="fc" id="L1489">    int prune[] = new int[values];</span>
<span class="fc bfc" id="L1490" title="All 2 branches covered.">    for (int z = 0; z &lt; values; z++) {</span>
<span class="fc" id="L1491">      totalsize += dictionaryArr[z].size();</span>

<span class="fc" id="L1493">      int array[] = new int[dictionaryArr[z].size()];</span>
<span class="fc" id="L1494">      int pos = 0;</span>
<span class="fc" id="L1495">      Iterator it = dictionaryArr[z].keySet().iterator();</span>
<span class="fc bfc" id="L1496" title="All 2 branches covered.">      while (it.hasNext()) {</span>
<span class="fc" id="L1497">	String word = (String)it.next();</span>
<span class="fc" id="L1498">	Count count = (Count)dictionaryArr[z].get(word);</span>
<span class="fc" id="L1499">	array[pos] = count.count;</span>
<span class="fc" id="L1500">	pos++;</span>
<span class="fc" id="L1501">      }</span>

      // sort the array
<span class="fc" id="L1504">      sortArray(array);</span>
<span class="fc bfc" id="L1505" title="All 2 branches covered.">      if (array.length &lt; m_WordsToKeep) {</span>
	// if there aren't enough words, set the threshold to
	// minFreq
<span class="fc" id="L1508">	prune[z] = m_minTermFreq;</span>
      } else {
	// otherwise set it to be at least minFreq
<span class="fc" id="L1511">	prune[z] = Math.max(m_minTermFreq, </span>
	    array[array.length - m_WordsToKeep]);
      }
    }

    // Convert the dictionary into an attribute index
    // and create one attribute per word
<span class="fc" id="L1518">    FastVector attributes = new FastVector(totalsize +</span>
<span class="fc" id="L1519">	getInputFormat().numAttributes());</span>

    // Add the non-converted attributes 
<span class="fc" id="L1522">    int classIndex = -1;</span>
<span class="fc bfc" id="L1523" title="All 2 branches covered.">    for (int i = 0; i &lt; getInputFormat().numAttributes(); i++) {</span>
<span class="fc bfc" id="L1524" title="All 2 branches covered.">      if (!m_SelectedRange.isInRange(i)) { </span>
<span class="fc bfc" id="L1525" title="All 2 branches covered.">	if (getInputFormat().classIndex() == i) {</span>
<span class="fc" id="L1526">	  classIndex = attributes.size();</span>
	}
<span class="fc" id="L1528">	attributes.addElement(getInputFormat().attribute(i).copy());</span>
      }     
    }

    // Add the word vector attributes (eliminating duplicates
	// that occur in multiple classes)
<span class="fc" id="L1534">    TreeMap newDictionary = new TreeMap();</span>
<span class="fc" id="L1535">    int index = attributes.size();</span>
<span class="fc bfc" id="L1536" title="All 2 branches covered.">    for(int z = 0; z &lt; values; z++) {</span>
<span class="fc" id="L1537">      Iterator it = dictionaryArr[z].keySet().iterator();</span>
<span class="fc bfc" id="L1538" title="All 2 branches covered.">      while (it.hasNext()) {</span>
<span class="fc" id="L1539">	String word = (String)it.next();</span>
<span class="fc" id="L1540">	Count count = (Count)dictionaryArr[z].get(word);</span>
<span class="fc bfc" id="L1541" title="All 2 branches covered.">	if (count.count &gt;= prune[z]) {</span>
<span class="pc bpc" id="L1542" title="1 of 2 branches missed.">	  if(newDictionary.get(word) == null) {</span>
<span class="fc" id="L1543">	    newDictionary.put(word, new Integer(index++));</span>
<span class="fc" id="L1544">	    attributes.addElement(new Attribute(m_Prefix + word));</span>
	  }
	}
<span class="fc" id="L1547">      }</span>
    }

    // Compute document frequencies
<span class="fc" id="L1551">    m_DocsCounts = new int[attributes.size()];</span>
<span class="fc" id="L1552">    Iterator it = newDictionary.keySet().iterator();</span>
<span class="fc bfc" id="L1553" title="All 2 branches covered.">    while(it.hasNext()) {</span>
<span class="fc" id="L1554">      String word = (String) it.next();</span>
<span class="fc" id="L1555">      int idx = ((Integer)newDictionary.get(word)).intValue();</span>
<span class="fc" id="L1556">      int docsCount=0;</span>
<span class="fc bfc" id="L1557" title="All 2 branches covered.">      for(int j=0; j&lt;values; j++) {</span>
<span class="fc" id="L1558">	Count c = (Count) dictionaryArr[j].get(word);</span>
<span class="pc bpc" id="L1559" title="1 of 2 branches missed.">	if(c!=null)</span>
<span class="fc" id="L1560">	  docsCount += c.docCount;</span>
      }
<span class="fc" id="L1562">      m_DocsCounts[idx]=docsCount;</span>
<span class="fc" id="L1563">    }</span>

    // Trim vector and set instance variables
<span class="fc" id="L1566">    attributes.trimToSize();</span>
<span class="fc" id="L1567">    m_Dictionary = newDictionary;</span>
<span class="fc" id="L1568">    m_NumInstances = getInputFormat().numInstances();</span>

    // Set the filter's output format
<span class="fc" id="L1571">    Instances outputFormat = new Instances(getInputFormat().relationName(), </span>
	attributes, 0);
<span class="fc" id="L1573">    outputFormat.setClassIndex(classIndex);</span>
<span class="fc" id="L1574">    setOutputFormat(outputFormat);</span>
<span class="fc" id="L1575">  }</span>

  /**
   * Converts the instance w/o normalization.
   * 
   * @oaram instance the instance to convert
   * @param v
   * @return the conerted instance
   */
  private int convertInstancewoDocNorm(Instance instance, FastVector v) {

    // Convert the instance into a sorted set of indexes
<span class="fc" id="L1587">    TreeMap contained = new TreeMap();</span>

    // Copy all non-converted attributes from input to output
<span class="fc" id="L1590">    int firstCopy = 0;</span>
<span class="fc bfc" id="L1591" title="All 2 branches covered.">    for (int i = 0; i &lt; getInputFormat().numAttributes(); i++) {</span>
<span class="fc bfc" id="L1592" title="All 2 branches covered.">      if (!m_SelectedRange.isInRange(i)) { </span>
<span class="pc bpc" id="L1593" title="1 of 2 branches missed.">	if (getInputFormat().attribute(i).type() != Attribute.STRING &amp;&amp; </span>
<span class="pc bpc" id="L1594" title="1 of 2 branches missed.">            getInputFormat().attribute(i).type() != Attribute.RELATIONAL) {</span>
	  // Add simple nominal and numeric attributes directly
<span class="fc bfc" id="L1596" title="All 2 branches covered.">	  if (instance.value(i) != 0.0) {</span>
<span class="fc" id="L1597">	    contained.put(new Integer(firstCopy), </span>
<span class="fc" id="L1598">		new Double(instance.value(i)));</span>
	  } 
	} else {
<span class="nc bnc" id="L1601" title="All 2 branches missed.">	  if (instance.isMissing(i)) {</span>
<span class="nc" id="L1602">	    contained.put(new Integer(firstCopy),</span>
<span class="nc" id="L1603">		new Double(Instance.missingValue()));</span>
<span class="nc bnc" id="L1604" title="All 2 branches missed.">	  } else if (getInputFormat().attribute(i).type() == Attribute.STRING) {</span>

	    // If this is a string attribute, we have to first add
	    // this value to the range of possible values, then add
	    // its new internal index.
<span class="nc bnc" id="L1609" title="All 2 branches missed.">	    if (outputFormatPeek().attribute(firstCopy).numValues() == 0) {</span>
	      // Note that the first string value in a
	      // SparseInstance doesn't get printed.
<span class="nc" id="L1612">	      outputFormatPeek().attribute(firstCopy)</span>
<span class="nc" id="L1613">	      .addStringValue(&quot;Hack to defeat SparseInstance bug&quot;);</span>
	    }
<span class="nc" id="L1615">	    int newIndex = outputFormatPeek().attribute(firstCopy)</span>
<span class="nc" id="L1616">	    .addStringValue(instance.stringValue(i));</span>
<span class="nc" id="L1617">	    contained.put(new Integer(firstCopy), </span>
		new Double(newIndex));
<span class="nc" id="L1619">	  } else {</span>
	    // relational
<span class="nc bnc" id="L1621" title="All 2 branches missed.">            if (outputFormatPeek().attribute(firstCopy).numValues() == 0) {</span>
<span class="nc" id="L1622">              Instances relationalHeader = outputFormatPeek().attribute(firstCopy).relation();</span>
              
              // hack to defeat sparse instances bug
<span class="nc" id="L1625">              outputFormatPeek().attribute(firstCopy).addRelation(relationalHeader);</span>
            }
<span class="nc" id="L1627">            int newIndex = outputFormatPeek().attribute(firstCopy)</span>
<span class="nc" id="L1628">              .addRelation(instance.relationalValue(i));</span>
<span class="nc" id="L1629">            contained.put(new Integer(firstCopy), new Double(newIndex));</span>
	  }
	}
<span class="fc" id="L1632">	firstCopy++;</span>
      }     
    }

<span class="fc bfc" id="L1636" title="All 2 branches covered.">    for (int j = 0; j &lt; instance.numAttributes(); j++) { </span>
      //if ((getInputFormat().attribute(j).type() == Attribute.STRING) 
<span class="fc bfc" id="L1638" title="All 2 branches covered.">      if (m_SelectedRange.isInRange(j)</span>
<span class="fc bfc" id="L1639" title="All 2 branches covered.">	  &amp;&amp; (instance.isMissing(j) == false)) {          </span>

<span class="fc" id="L1641">	m_Tokenizer.tokenize(instance.stringValue(j));</span>

<span class="fc bfc" id="L1643" title="All 2 branches covered.">	while (m_Tokenizer.hasMoreElements()) {</span>
<span class="fc" id="L1644">	  String word = (String)m_Tokenizer.nextElement(); </span>
<span class="pc bpc" id="L1645" title="1 of 2 branches missed.">	  if(this.m_lowerCaseTokens==true)</span>
<span class="nc" id="L1646">	    word = word.toLowerCase();</span>
<span class="fc" id="L1647">	  word = m_Stemmer.stem(word);</span>
<span class="fc" id="L1648">	  Integer index = (Integer) m_Dictionary.get(word);</span>
<span class="fc bfc" id="L1649" title="All 2 branches covered.">	  if (index != null) {</span>
<span class="pc bpc" id="L1650" title="1 of 2 branches missed.">	    if (m_OutputCounts) { // Separate if here rather than two lines down to avoid hashtable lookup</span>
<span class="nc" id="L1651">	      Double count = (Double)contained.get(index);</span>
<span class="nc bnc" id="L1652" title="All 2 branches missed.">	    if (count != null) {</span>
<span class="nc" id="L1653">	      contained.put(index, new Double(count.doubleValue() + 1.0));</span>
	    } else {
<span class="nc" id="L1655">	      contained.put(index, new Double(1));</span>
	    }
<span class="nc" id="L1657">	    } else {</span>
<span class="fc" id="L1658">	      contained.put(index, new Double(1));</span>
	    }                
	  }
<span class="fc" id="L1661">	}</span>
      }
    }

    //Doing TFTransform
<span class="pc bpc" id="L1666" title="1 of 2 branches missed.">    if(m_TFTransform==true) {</span>
<span class="nc" id="L1667">      Iterator it = contained.keySet().iterator();</span>
<span class="nc bnc" id="L1668" title="All 2 branches missed.">      for(int i=0; it.hasNext(); i++) {</span>
<span class="nc" id="L1669">	Integer index = (Integer)it.next();</span>
<span class="nc bnc" id="L1670" title="All 2 branches missed.">	if( index.intValue() &gt;= firstCopy ) { </span>
<span class="nc" id="L1671">	  double val = ((Double)contained.get(index)).doubleValue();</span>
<span class="nc" id="L1672">	  val = Math.log(val+1);</span>
<span class="nc" id="L1673">	  contained.put(index, new Double(val));</span>
	}
      }
    }

    //Doing IDFTransform
<span class="pc bpc" id="L1679" title="1 of 2 branches missed.">    if(m_IDFTransform==true) {</span>
<span class="nc" id="L1680">      Iterator it = contained.keySet().iterator();</span>
<span class="nc bnc" id="L1681" title="All 2 branches missed.">      for(int i=0; it.hasNext(); i++) {</span>
<span class="nc" id="L1682">	Integer index = (Integer)it.next();</span>
<span class="nc bnc" id="L1683" title="All 2 branches missed.">	if( index.intValue() &gt;= firstCopy ) {</span>
<span class="nc" id="L1684">	  double val = ((Double)contained.get(index)).doubleValue();</span>
<span class="nc" id="L1685">	  val = val*Math.log( m_NumInstances /</span>
<span class="nc" id="L1686">	      (double) m_DocsCounts[index.intValue()] );</span>
<span class="nc" id="L1687">	  contained.put(index, new Double(val));</span>
	}
      }        
    }

    // Convert the set to structures needed to create a sparse instance.
<span class="fc" id="L1693">    double [] values = new double [contained.size()];</span>
<span class="fc" id="L1694">    int [] indices = new int [contained.size()];</span>
<span class="fc" id="L1695">    Iterator it = contained.keySet().iterator();</span>
<span class="fc bfc" id="L1696" title="All 2 branches covered.">    for (int i = 0; it.hasNext(); i++) {</span>
<span class="fc" id="L1697">      Integer index = (Integer)it.next();</span>
<span class="fc" id="L1698">      Double value = (Double)contained.get(index);</span>
<span class="fc" id="L1699">      values[i] = value.doubleValue();</span>
<span class="fc" id="L1700">      indices[i] = index.intValue();</span>
    }

<span class="fc" id="L1703">    Instance inst = new SparseInstance(instance.weight(), values, indices, </span>
<span class="fc" id="L1704">	outputFormatPeek().numAttributes());</span>
<span class="fc" id="L1705">    inst.setDataset(outputFormatPeek());</span>

<span class="fc" id="L1707">    v.addElement(inst);</span>

<span class="fc" id="L1709">    return firstCopy;    </span>
  }

  /**
   * Normalizes given instance to average doc length (only the newly
   * constructed attributes).
   * 
   * @param inst	the instance to normalize
   * @param firstCopy
   * @throws Exception if avg. doc length not set
   */
  private void normalizeInstance(Instance inst, int firstCopy) 
  throws Exception {

<span class="nc" id="L1723">    double docLength = 0;</span>

<span class="nc bnc" id="L1725" title="All 2 branches missed.">    if (m_AvgDocLength &lt; 0) {</span>
<span class="nc" id="L1726">      throw new Exception(&quot;Average document length not set.&quot;);</span>
    }

    // Compute length of document vector
<span class="nc bnc" id="L1730" title="All 2 branches missed.">    for(int j=0; j&lt;inst.numValues(); j++) {</span>
<span class="nc bnc" id="L1731" title="All 2 branches missed.">      if(inst.index(j)&gt;=firstCopy) {</span>
<span class="nc" id="L1732">	docLength += inst.valueSparse(j) * inst.valueSparse(j);</span>
      }
    }        
<span class="nc" id="L1735">    docLength = Math.sqrt(docLength);</span>

    // Normalize document vector
<span class="nc bnc" id="L1738" title="All 2 branches missed.">    for(int j=0; j&lt;inst.numValues(); j++) {</span>
<span class="nc bnc" id="L1739" title="All 2 branches missed.">      if(inst.index(j)&gt;=firstCopy) {</span>
<span class="nc" id="L1740">	double val = inst.valueSparse(j) * m_AvgDocLength / docLength;</span>
<span class="nc" id="L1741">	inst.setValueSparse(j, val);</span>
<span class="nc bnc" id="L1742" title="All 2 branches missed.">	if (val == 0){</span>
<span class="nc" id="L1743">	  System.err.println(&quot;setting value &quot;+inst.index(j)+&quot; to zero.&quot;);</span>
<span class="nc" id="L1744">	  j--;</span>
	}
      }
    }        
<span class="nc" id="L1748">  }</span>
  
  /**
   * Returns the revision string.
   * 
   * @return		the revision
   */
  public String getRevision() {
<span class="nc" id="L1756">    return RevisionUtils.extract(&quot;$Revision: 9565 $&quot;);</span>
  }

  /**
   * Main method for testing this class.
   *
   * @param argv should contain arguments to the filter: 
   * use -h for help
   */
  public static void main(String [] argv) {
<span class="nc" id="L1766">    runFilter(new StringToWordVector(), argv);</span>
<span class="nc" id="L1767">  }</span>
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>
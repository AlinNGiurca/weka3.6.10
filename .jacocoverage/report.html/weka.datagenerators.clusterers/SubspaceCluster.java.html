<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SubspaceCluster.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCoverage analysis of project &quot;Weka-3.6.10&quot; (powered by JaCoCo from EclEmma)</a> &gt; <a href="index.source.html" class="el_package">weka.datagenerators.clusterers</a> &gt; <span class="el_source">SubspaceCluster.java</span></div><h1>SubspaceCluster.java</h1><pre class="source lang-java linenums">/*
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation; either version 2 of the License, or
 *    (at your option) any later version.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not, write to the Free Software
 *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/*
 *    SubspaceCluster.java
 *    Copyright (C) 2001 University of Waikato, Hamilton, New Zealand
 *
 */

package weka.datagenerators.clusterers;

import weka.core.Attribute;
import weka.core.FastVector;
import weka.core.Instance;
import weka.core.Instances;
import weka.core.Option;
import weka.core.Range;
import weka.core.RevisionUtils;
import weka.core.Tag;
import weka.core.Utils;
import weka.datagenerators.ClusterDefinition;
import weka.datagenerators.ClusterGenerator;

import java.util.Enumeration;
import java.util.Random;
import java.util.Vector;

/**
 &lt;!-- globalinfo-start --&gt;
 * A data generator that produces data points in hyperrectangular subspace clusters.
 * &lt;p/&gt;
 &lt;!-- globalinfo-end --&gt;
 *
 &lt;!-- options-start --&gt;
 * Valid options are: &lt;p/&gt;
 * 
 * &lt;pre&gt; -h
 *  Prints this help.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -o &amp;lt;file&amp;gt;
 *  The name of the output file, otherwise the generated data is
 *  printed to stdout.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -r &amp;lt;name&amp;gt;
 *  The name of the relation.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -d
 *  Whether to print debug informations.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -S
 *  The seed for random function (default 1)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -a &amp;lt;num&amp;gt;
 *  The number of attributes (default 1).&lt;/pre&gt;
 * 
 * &lt;pre&gt; -c
 *  Class Flag, if set, the cluster is listed in extra attribute.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -b &amp;lt;range&amp;gt;
 *  The indices for boolean attributes.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -m &amp;lt;range&amp;gt;
 *  The indices for nominal attributes.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -P &amp;lt;num&amp;gt;
 *  The noise rate in percent (default 0.0).
 *  Can be between 0% and 30%. (Remark: The original 
 *  algorithm only allows noise up to 10%.)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -C &amp;lt;cluster-definition&amp;gt;
 *  A cluster definition of class 'SubspaceClusterDefinition'
 *  (definition needs to be quoted to be recognized as 
 *  a single argument).&lt;/pre&gt;
 * 
 * &lt;pre&gt; 
 * Options specific to weka.datagenerators.clusterers.SubspaceClusterDefinition:
 * &lt;/pre&gt;
 * 
 * &lt;pre&gt; -A &amp;lt;range&amp;gt;
 *  Generates randomly distributed instances in the cluster.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -U &amp;lt;range&amp;gt;
 *  Generates uniformly distributed instances in the cluster.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -G &amp;lt;range&amp;gt;
 *  Generates gaussian distributed instances in the cluster.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -D &amp;lt;num&amp;gt;,&amp;lt;num&amp;gt;
 *  The attribute min/max (-A and -U) or mean/stddev (-G) for
 *  the cluster.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -N &amp;lt;num&amp;gt;..&amp;lt;num&amp;gt;
 *  The range of number of instances per cluster (default 1..50).&lt;/pre&gt;
 * 
 * &lt;pre&gt; -I
 *  Uses integer instead of continuous values (default continuous).&lt;/pre&gt;
 * 
 &lt;!-- options-end --&gt;
 *
 * @author Gabi Schmidberger (gabi@cs.waikato.ac.nz)
 * @author  FracPete (fracpete at waikato dot ac dot nz)
 * @version $Revision: 1.5 $ 
 */
public class SubspaceCluster 
  extends ClusterGenerator {

  /** for serialization */
  static final long serialVersionUID = -3454999858505621128L;
  
  /** noise rate in percent (option P,  between 0 and 30)*/ 
  protected double m_NoiseRate;

  /** cluster list */
  protected ClusterDefinition[] m_Clusters;

  /** if nominal, store number of values */
  protected int[] m_numValues;

  /** store global min values */
  protected double[] m_globalMinValue;

  /** store global max values */
  protected double[] m_globalMaxValue;

  /** cluster type: uniform/random */
  public static final int UNIFORM_RANDOM = 0;  
  /** cluster type: total uniform */
  public static final int TOTAL_UNIFORM = 1;
  /** cluster type: gaussian */
  public static final int GAUSSIAN = 2;
  /** the tags for the cluster types */
<span class="fc" id="L145">  public static final Tag[] TAGS_CLUSTERTYPE = {</span>
    new Tag(UNIFORM_RANDOM, &quot;uniform/random&quot;),
    new Tag(TOTAL_UNIFORM,  &quot;total uniform&quot;),
    new Tag(GAUSSIAN,       &quot;gaussian&quot;)
  };

  /** cluster subtype: continuous */
  public static final int CONTINUOUS = 0;
  /** cluster subtype: integer */
  public static final int INTEGER = 1;
  /** the tags for the cluster types */
<span class="fc" id="L156">  public static final Tag[] TAGS_CLUSTERSUBTYPE = {</span>
    new Tag(CONTINUOUS, &quot;continuous&quot;),
    new Tag(INTEGER,    &quot;integer&quot;)
  };

  /**
   * initializes the generator, sets the number of clusters to 0, since user
   * has to specify them explicitly
   */
  public SubspaceCluster() {
<span class="fc" id="L166">    super();</span>

<span class="fc" id="L168">    setNoiseRate(defaultNoiseRate());</span>
<span class="fc" id="L169">  }</span>

  /**
   * Returns a string describing this data generator.
   *
   * @return a description of the data generator suitable for
   * displaying in the explorer/experimenter gui
   */
  public String globalInfo() {
<span class="nc" id="L178">    return &quot;A data generator that produces data points in &quot;</span>
      + &quot;hyperrectangular subspace clusters.&quot;;
  }

  /**
   * Returns an enumeration describing the available options.
   *
   * @return an enumeration of all the available options
   */
  public Enumeration listOptions() {
<span class="fc" id="L188">    Vector result = enumToVector(super.listOptions());</span>

<span class="fc" id="L190">    result.addElement(new Option(</span>
          &quot;\tThe noise rate in percent (default &quot; 
<span class="fc" id="L192">          + defaultNoiseRate() + &quot;).\n&quot;</span>
          + &quot;\tCan be between 0% and 30%. (Remark: The original \n&quot;
          + &quot;\talgorithm only allows noise up to 10%.)&quot;,
          &quot;P&quot;, 1, &quot;-P &lt;num&gt;&quot;));

<span class="fc" id="L197">    result.addElement(new Option(</span>
          &quot;\tA cluster definition of class '&quot; 
<span class="fc" id="L199">	  + SubspaceClusterDefinition.class.getName().replaceAll(&quot;.*\\.&quot;, &quot;&quot;) + &quot;'\n&quot;</span>
	  + &quot;\t(definition needs to be quoted to be recognized as \n&quot;
	  + &quot;\ta single argument).&quot;,
          &quot;C&quot;, 1, &quot;-C &lt;cluster-definition&gt;&quot;));

<span class="fc" id="L204">    result.addElement(new Option(</span>
	      &quot;&quot;, &quot;&quot;, 0, 
	      &quot;\nOptions specific to &quot; 
<span class="fc" id="L207">	      + SubspaceClusterDefinition.class.getName() + &quot;:&quot;));</span>

<span class="fc" id="L209">    result.addAll(</span>
<span class="fc" id="L210">        enumToVector(new SubspaceClusterDefinition(this).listOptions()));</span>

<span class="fc" id="L212">    return result.elements();</span>
  }

  /**
   * Parses a list of options for this object. &lt;p/&gt;
   *
   &lt;!-- options-start --&gt;
   * Valid options are: &lt;p/&gt;
   * 
   * &lt;pre&gt; -h
   *  Prints this help.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -o &amp;lt;file&amp;gt;
   *  The name of the output file, otherwise the generated data is
   *  printed to stdout.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -r &amp;lt;name&amp;gt;
   *  The name of the relation.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -d
   *  Whether to print debug informations.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -S
   *  The seed for random function (default 1)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -a &amp;lt;num&amp;gt;
   *  The number of attributes (default 1).&lt;/pre&gt;
   * 
   * &lt;pre&gt; -c
   *  Class Flag, if set, the cluster is listed in extra attribute.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -b &amp;lt;range&amp;gt;
   *  The indices for boolean attributes.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -m &amp;lt;range&amp;gt;
   *  The indices for nominal attributes.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -P &amp;lt;num&amp;gt;
   *  The noise rate in percent (default 0.0).
   *  Can be between 0% and 30%. (Remark: The original 
   *  algorithm only allows noise up to 10%.)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -C &amp;lt;cluster-definition&amp;gt;
   *  A cluster definition of class 'SubspaceClusterDefinition'
   *  (definition needs to be quoted to be recognized as 
   *  a single argument).&lt;/pre&gt;
   * 
   * &lt;pre&gt; 
   * Options specific to weka.datagenerators.clusterers.SubspaceClusterDefinition:
   * &lt;/pre&gt;
   * 
   * &lt;pre&gt; -A &amp;lt;range&amp;gt;
   *  Generates randomly distributed instances in the cluster.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -U &amp;lt;range&amp;gt;
   *  Generates uniformly distributed instances in the cluster.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -G &amp;lt;range&amp;gt;
   *  Generates gaussian distributed instances in the cluster.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -D &amp;lt;num&amp;gt;,&amp;lt;num&amp;gt;
   *  The attribute min/max (-A and -U) or mean/stddev (-G) for
   *  the cluster.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -N &amp;lt;num&amp;gt;..&amp;lt;num&amp;gt;
   *  The range of number of instances per cluster (default 1..50).&lt;/pre&gt;
   * 
   * &lt;pre&gt; -I
   *  Uses integer instead of continuous values (default continuous).&lt;/pre&gt;
   * 
   &lt;!-- options-end --&gt;
   *
   * @param options the list of options as an array of strings
   * @throws Exception if an option is not supported
   */
  public void setOptions(String[] options) throws Exception {
    String                      tmpStr;
    SubspaceClusterDefinition   cl;
    Vector                      list;
    int                         clCount;

<span class="fc" id="L293">    super.setOptions(options);</span>

<span class="fc" id="L295">    m_numValues = new int[getNumAttributes()];</span>
    // numValues might be changed by a cluster definition
    // (only relevant for nominal data)
<span class="fc bfc" id="L298" title="All 2 branches covered.">    for (int i = 0; i &lt; getNumAttributes(); i++)</span>
<span class="fc" id="L299">      m_numValues[i] = 1;</span>

<span class="fc" id="L301">    tmpStr = Utils.getOption('P', options);</span>
<span class="fc bfc" id="L302" title="All 2 branches covered.">    if (tmpStr.length() != 0)</span>
<span class="fc" id="L303">      setNoiseRate(Double.parseDouble(tmpStr));</span>
    else
<span class="fc" id="L305">      setNoiseRate(defaultNoiseRate());</span>

    // cluster definitions
<span class="fc" id="L308">    list = new Vector();</span>
    
<span class="fc" id="L310">    clCount = 0;</span>
    do {
<span class="fc" id="L312">      tmpStr = Utils.getOption('C', options);</span>
<span class="fc bfc" id="L313" title="All 2 branches covered.">      if (tmpStr.length() != 0) {</span>
<span class="fc" id="L314">        clCount++;</span>
<span class="fc" id="L315">        cl = new SubspaceClusterDefinition(this);</span>
<span class="fc" id="L316">        cl.setOptions(Utils.splitOptions(tmpStr));</span>
<span class="fc" id="L317">        list.add(cl);</span>
      }
    }
<span class="fc bfc" id="L320" title="All 2 branches covered.">    while (tmpStr.length() != 0);</span>

<span class="fc" id="L322">    m_Clusters = (ClusterDefinition[]) </span>
<span class="fc" id="L323">                    list.toArray(new ClusterDefinition[list.size()]);</span>
    // in case no cluster definition was provided, make sure that there's at
    // least one definition present -&gt; see getClusters()
<span class="fc" id="L326">    getClusters();</span>
<span class="fc" id="L327">  }</span>


  /**
   * Gets the current settings of the datagenerator.
   *
   * @return an array of strings suitable for passing to setOptions
   */
  public String[] getOptions() {
    Vector        result;
    String[]      options;
    int           i;

<span class="fc" id="L340">    result  = new Vector();</span>
<span class="fc" id="L341">    options = super.getOptions();</span>
<span class="fc bfc" id="L342" title="All 2 branches covered.">    for (i = 0; i &lt; options.length; i++)</span>
<span class="fc" id="L343">      result.add(options[i]);</span>

<span class="fc" id="L345">    result.add(&quot;-P&quot;); </span>
<span class="fc" id="L346">    result.add(&quot;&quot; + getNoiseRate());</span>

<span class="fc bfc" id="L348" title="All 2 branches covered.">    for (i = 0; i &lt; getClusters().length; i++)  {</span>
<span class="fc" id="L349">      result.add(&quot;-C&quot;);</span>
<span class="fc" id="L350">      result.add(Utils.joinOptions(getClusters()[i].getOptions()));</span>
    }

<span class="fc" id="L353">    return (String[]) result.toArray(new String[result.size()]);</span>
  }

  /**
   * returns the current cluster definitions, if necessary initializes them
   * 
   * @return the current cluster definitions
   */
  protected ClusterDefinition[] getClusters() {
<span class="fc bfc" id="L362" title="All 4 branches covered.">    if ( (m_Clusters == null) || (m_Clusters.length == 0) ) {</span>
<span class="fc bfc" id="L363" title="All 2 branches covered.">      if (m_Clusters != null)</span>
<span class="fc" id="L364">        System.out.println(&quot;NOTE: at least 1 cluster definition is necessary, &quot; </span>
            + &quot;created default one.&quot;);
<span class="fc" id="L366">      m_Clusters = new ClusterDefinition[]{new SubspaceClusterDefinition(this)};</span>
    }

<span class="fc" id="L369">    return m_Clusters;</span>
  }

  /**
   * returns the default number of attributes
   * 
   * @return the default number of attributes
   */
  protected int defaultNumAttributes() {
<span class="fc" id="L378">    return 1;</span>
  }

  /**
   * Sets the number of attributes the dataset should have.
   * @param numAttributes the new number of attributes
   */
  public void setNumAttributes(int numAttributes) {
<span class="fc" id="L386">    super.setNumAttributes(numAttributes);</span>
<span class="fc" id="L387">    m_numValues = new int[getNumAttributes()];</span>
<span class="fc" id="L388">  }</span>
  
  /**
   * Returns the tip text for this property
   * 
   * @return tip text for this property suitable for
   *         displaying in the explorer/experimenter gui
   */
  public String numAttributesTipText() {
<span class="nc" id="L397">    return &quot;The number of attributes the generated data will contain (Note: they must be covered by the cluster definitions!)&quot;;</span>
  }

  /**
   * returns the default noise rate
   * 
   * @return the default noise rate
   */
  protected double defaultNoiseRate() {
<span class="fc" id="L406">    return 0.0;</span>
  }

  /**
   * Gets the percentage of noise set.
   *
   * @return the percentage of noise set
   */
  public double getNoiseRate() { 
<span class="fc" id="L415">    return m_NoiseRate; </span>
  }

  /**
   * Sets the percentage of noise set.
   *
   * @param newNoiseRate new percentage of noise 
   */
  public void setNoiseRate(double newNoiseRate) {
<span class="fc" id="L424">    m_NoiseRate = newNoiseRate;</span>
<span class="fc" id="L425">  }</span>

  /**
   * Returns the tip text for this property
   * 
   * @return tip text for this property suitable for
   *         displaying in the explorer/experimenter gui
   */
  public String noiseRateTipText() {
<span class="nc" id="L434">    return &quot;The noise rate to use.&quot;;</span>
  }

  /**
   * returns the currently set clusters
   * 
   * @return the currently set clusters
   */
  public ClusterDefinition[] getClusterDefinitions() {
<span class="nc" id="L443">    return getClusters();</span>
  }

  /**
   * sets the clusters to use
   * 
   * @param value the clusters do use
   * @throws Exception if clusters are not the correct class
   */
  public void setClusterDefinitions(ClusterDefinition[] value) 
    throws Exception {

    String      indexStr;
    
<span class="nc" id="L457">    indexStr   = &quot;&quot;;</span>
<span class="nc" id="L458">    m_Clusters = value;</span>
<span class="nc bnc" id="L459" title="All 2 branches missed.">    for (int i = 0; i &lt; getClusters().length; i++) {</span>
<span class="nc bnc" id="L460" title="All 2 branches missed.">      if (!(getClusters()[i] instanceof SubspaceClusterDefinition)) {</span>
<span class="nc bnc" id="L461" title="All 2 branches missed.">        if (indexStr.length() != 0)</span>
<span class="nc" id="L462">          indexStr += &quot;,&quot;;</span>
<span class="nc" id="L463">        indexStr += &quot;&quot; + (i+1);</span>
      }
<span class="nc" id="L465">      getClusters()[i].setParent(this);</span>
<span class="nc" id="L466">      getClusters()[i].setOptions(getClusters()[i].getOptions()); // for initializing!</span>
    }

    // any wrong classes encountered?
<span class="nc bnc" id="L470" title="All 2 branches missed.">    if (indexStr.length() != 0)</span>
<span class="nc" id="L471">      throw new Exception(&quot;These cluster definitions are not '&quot; </span>
<span class="nc" id="L472">          + SubspaceClusterDefinition.class.getName() + &quot;': &quot; + indexStr);</span>
<span class="nc" id="L473">  }</span>

  /**
   * Returns the tip text for this property
   * 
   * @return tip text for this property suitable for
   *         displaying in the explorer/experimenter gui
   */
  public String clusterDefinitionsTipText() {
<span class="nc" id="L482">    return &quot;The clusters to use.&quot;;</span>
  }

  /**
   * Checks, whether all attributes are covered by cluster definitions and 
   * returns TRUE in that case.
   * 
   * @return whether all attributes are covered
   */
  protected boolean checkCoverage() {
    int         i;
    int         n;
    int[]       count;
    Range       r;
    String      attrIndex;
    SubspaceClusterDefinition  cl;
    
    // check whether all the attributes are covered
<span class="fc" id="L500">    count = new int[getNumAttributes()];</span>
<span class="fc bfc" id="L501" title="All 2 branches covered.">    for (i = 0; i &lt; getNumAttributes(); i++) {</span>
<span class="fc bfc" id="L502" title="All 2 branches covered.">      for (n = 0; n &lt; getClusters().length; n++) {</span>
<span class="fc" id="L503">        cl = (SubspaceClusterDefinition) getClusters()[n];</span>
<span class="fc" id="L504">        r  = new Range(cl.getAttrIndexRange());</span>
<span class="fc" id="L505">        r.setUpper(getNumAttributes());</span>
<span class="pc bpc" id="L506" title="1 of 2 branches missed.">        if (r.isInRange(i))</span>
<span class="fc" id="L507">          count[i]++;</span>
      }
    }

    // list all indices that are not covered
<span class="fc" id="L512">    attrIndex = &quot;&quot;;</span>
<span class="fc bfc" id="L513" title="All 2 branches covered.">    for (i = 0; i &lt; count.length; i++) {</span>
<span class="pc bpc" id="L514" title="1 of 2 branches missed.">      if (count[i] == 0) {</span>
<span class="nc bnc" id="L515" title="All 2 branches missed.">        if (attrIndex.length() != 0)</span>
<span class="nc" id="L516">          attrIndex += &quot;,&quot;;</span>
<span class="nc" id="L517">        attrIndex += (i+1);</span>
      }
    }

<span class="pc bpc" id="L521" title="1 of 2 branches missed.">    if (attrIndex.length() != 0)</span>
<span class="nc" id="L522">      throw new IllegalArgumentException(</span>
          &quot;The following attributes are not covered by a cluster &quot;
          + &quot;definition: &quot; + attrIndex + &quot;\n&quot;);

<span class="fc" id="L526">    return true;</span>
  }

  /**
   * Gets the single mode flag.
   *
   * @return true if methode generateExample can be used.
   */
  public boolean getSingleModeFlag() { 
<span class="fc" id="L535">    return false; </span>
  }

  /**
   * Initializes the format for the dataset produced. 
   *
   * @return the output data format
   * @throws Exception data format could not be defined 
   */

  public Instances defineDataFormat() throws Exception {

    // initialize
<span class="fc" id="L548">    setOptions(getOptions());</span>

<span class="fc" id="L550">    checkCoverage();</span>

<span class="fc" id="L552">    Random random = new Random (getSeed());</span>
<span class="fc" id="L553">    setRandom(random);</span>
    Instances dataset;
<span class="fc" id="L555">    FastVector attributes = new FastVector(3);</span>
    Attribute attribute;
<span class="fc" id="L557">    boolean classFlag = getClassFlag();</span>

<span class="fc" id="L559">    FastVector classValues = null;</span>
<span class="pc bpc" id="L560" title="1 of 2 branches missed.">    if (classFlag) </span>
<span class="nc" id="L561">      classValues = new FastVector(getClusters().length);     </span>
<span class="fc" id="L562">    FastVector boolValues = new FastVector(2);</span>
<span class="fc" id="L563">    boolValues.addElement(&quot;false&quot;);</span>
<span class="fc" id="L564">    boolValues.addElement(&quot;true&quot;);</span>
<span class="fc" id="L565">    FastVector nomValues = null;</span>

    // define dataset
<span class="fc bfc" id="L568" title="All 2 branches covered.">    for (int i = 0; i &lt; getNumAttributes(); i++) {</span>
      // define boolean attribute
<span class="pc bpc" id="L570" title="1 of 2 branches missed.">      if (m_booleanCols.isInRange(i)) {</span>
<span class="nc" id="L571">        attribute = new Attribute(&quot;B&quot; + i, boolValues);</span>
      } 
<span class="pc bpc" id="L573" title="1 of 2 branches missed.">      else if (m_nominalCols.isInRange(i)) {</span>
        // define nominal attribute
<span class="nc" id="L575">        nomValues = new FastVector(m_numValues[i]);</span>
<span class="nc bnc" id="L576" title="All 2 branches missed.">        for (int j = 0; j &lt; m_numValues[i]; j++)</span>
<span class="nc" id="L577">          nomValues.addElement(&quot;value-&quot; + j);</span>
<span class="nc" id="L578">        attribute = new Attribute(&quot;N&quot; + i, nomValues);</span>
      } 
      else {
        // numerical attribute
<span class="fc" id="L582">        attribute = new Attribute(&quot;X&quot; + i); </span>
      }
<span class="fc" id="L584">      attributes.addElement(attribute);</span>
    }

<span class="pc bpc" id="L587" title="1 of 2 branches missed.">    if (classFlag) {</span>
<span class="nc bnc" id="L588" title="All 2 branches missed.">      for (int i = 0; i &lt; getClusters().length; i++)</span>
<span class="nc" id="L589">        classValues.addElement(&quot;c&quot; + i);</span>
<span class="nc" id="L590">      attribute = new Attribute (&quot;class&quot;, classValues); </span>
<span class="nc" id="L591">      attributes.addElement(attribute);</span>
    }

<span class="fc" id="L594">    dataset = new Instances(getRelationNameToUse(), attributes, 0);</span>
<span class="pc bpc" id="L595" title="1 of 2 branches missed.">    if (classFlag) </span>
<span class="nc" id="L596">      dataset.setClassIndex(m_NumAttributes);</span>

    // set dataset format of this class
<span class="fc" id="L599">    Instances format = new Instances(dataset, 0);</span>
<span class="fc" id="L600">    setDatasetFormat(format);</span>

<span class="fc bfc" id="L602" title="All 2 branches covered.">    for (int i = 0; i &lt; getClusters().length; i++) {</span>
<span class="fc" id="L603">      SubspaceClusterDefinition cl = (SubspaceClusterDefinition) getClusters()[i];</span>
<span class="fc" id="L604">      cl.setNumInstances(random);</span>
<span class="fc" id="L605">      cl.setParent(this);</span>
    }

<span class="fc" id="L608">    return dataset; </span>
  }

  /**
   * Returns true if attribute is boolean
   *@param index of the attribute
   *@return true if the attribute is boolean
   */
  public boolean isBoolean(int index) {
<span class="fc" id="L617">    return m_booleanCols.isInRange(index); </span>
  }

  /**
   * Returns true if attribute is nominal
   *@param index of the attribute
   *@return true if the attribute is nominal
   */
  public boolean isNominal(int index) {
<span class="fc" id="L626">    return m_nominalCols.isInRange(index);</span>
  }

  /**
   * returns array that stores the number of values for a nominal attribute.
   * 
   * @return the array that stores the number of values for a nominal attribute
   */
  public int[] getNumValues() {
<span class="nc" id="L635">    return m_numValues;</span>
  }

  /**
   * Generate an example of the dataset. 
   * @return the instance generated
   * @throws Exception if format not defined or generating &lt;br/&gt;
   * examples one by one is not possible, because voting is chosen
   */

  public Instance generateExample() throws Exception {
<span class="nc" id="L646">    throw new Exception(&quot;Examples cannot be generated one by one.&quot;);</span>
  }

  /**
   * Generate all examples of the dataset. 
   * @return the instance generated
   * @throws Exception if format not defined 
   */

  public Instances generateExamples() throws Exception {
<span class="fc" id="L656">    Instances format = getDatasetFormat();</span>
<span class="fc" id="L657">    Instance example = null;</span>

<span class="pc bpc" id="L659" title="1 of 2 branches missed.">    if (format == null) </span>
<span class="nc" id="L660">      throw new Exception(&quot;Dataset format not defined.&quot;);</span>

    // generate examples for one cluster after another
<span class="fc bfc" id="L663" title="All 2 branches covered.">    for (int cNum = 0; cNum &lt; getClusters().length; cNum++) {</span>
<span class="fc" id="L664">      SubspaceClusterDefinition cl  = (SubspaceClusterDefinition) getClusters()[cNum];</span>

      //get the number of instances to create
<span class="fc" id="L667">      int instNum = cl.getNumInstances();</span>

      //class value is c + cluster number
<span class="fc" id="L670">      String cName = &quot;c&quot; + cNum;</span>

<span class="pc bpc" id="L672" title="3 of 4 branches missed.">      switch (cl.getClusterType().getSelectedTag().getID()) {</span>
        case (UNIFORM_RANDOM):
<span class="fc bfc" id="L674" title="All 2 branches covered.">          for (int i = 0; i &lt; instNum; i++) {</span>
            // generate example
<span class="fc" id="L676">            example = generateExample(format, getRandom(), cl, cName);</span>
<span class="pc bpc" id="L677" title="1 of 2 branches missed.">            if (example != null)</span>
<span class="fc" id="L678">              format.add(example);</span>
          }
<span class="fc" id="L680">          break;</span>
        case (TOTAL_UNIFORM):
          // generate examples
<span class="nc bnc" id="L683" title="All 2 branches missed.">          if (!cl.isInteger())</span>
<span class="nc" id="L684">            generateUniformExamples(format, instNum, cl, cName);</span>
          else
<span class="nc" id="L686">            generateUniformIntegerExamples(format, instNum, cl, cName);</span>
<span class="nc" id="L687">          break;</span>
        case (GAUSSIAN):
          // generate examples
<span class="nc" id="L690">          generateGaussianExamples(format, instNum, getRandom(), cl, cName);</span>
          break;
      }
    }

<span class="fc" id="L695">    return format;</span>
  }

  /**
   * Generate an example of the dataset. 
   * 
   * @param format the dataset format
   * @param randomG the random number generator to use
   * @param cl the cluster definition
   * @param cName the class value
   * @return the generated instance
   */
  private Instance generateExample(
      Instances format, Random randomG, SubspaceClusterDefinition cl, 
      String cName) {

<span class="fc" id="L711">    boolean makeInteger = cl.isInteger();</span>
<span class="fc" id="L712">    int num = -1;</span>
<span class="fc" id="L713">    Instance example = null;</span>
<span class="fc" id="L714">    int numAtts = m_NumAttributes;</span>
<span class="pc bpc" id="L715" title="1 of 2 branches missed.">    if (getClassFlag()) numAtts++;</span>

<span class="fc" id="L717">    example = new Instance(numAtts);</span>
<span class="fc" id="L718">    example.setDataset(format);</span>
<span class="fc" id="L719">    boolean[] attributes = cl.getAttributes();</span>
<span class="fc" id="L720">    double[] minValue = cl.getMinValue();</span>
<span class="fc" id="L721">    double[] maxValue = cl.getMaxValue();</span>
    double value;

<span class="fc" id="L724">    int clusterI = -1;</span>
<span class="fc bfc" id="L725" title="All 2 branches covered.">    for (int i = 0; i &lt; m_NumAttributes; i++) {</span>
<span class="pc bpc" id="L726" title="1 of 2 branches missed.">      if (attributes[i]) {</span>
<span class="fc" id="L727">        clusterI++;</span>
<span class="fc" id="L728">        num++;</span>
        // boolean  or nominal attribute
<span class="pc bpc" id="L730" title="2 of 4 branches missed.">        if (isBoolean(i) || isNominal(i)) {</span>

<span class="nc bnc" id="L732" title="All 2 branches missed.">          if (minValue[clusterI] == maxValue[clusterI]) {</span>
<span class="nc" id="L733">            value = minValue[clusterI];</span>
          } 
          else {
<span class="nc" id="L736">            int numValues = (int)(maxValue[clusterI] - minValue[clusterI] + 1.0);</span>
<span class="nc" id="L737">            value = randomG.nextInt(numValues);</span>
<span class="nc" id="L738">            value += minValue[clusterI];</span>
<span class="nc" id="L739">          }</span>
        } 
        else {
          // numeric attribute
<span class="fc" id="L743">          value = randomG.nextDouble() * </span>
            (maxValue[num] - minValue[num]) + minValue[num];
<span class="pc bpc" id="L745" title="1 of 2 branches missed.">          if (makeInteger)</span>
<span class="nc" id="L746">            value = Math.round(value);</span>
        }
<span class="fc" id="L748">        example.setValue(i, value);</span>
      } 
      else {
<span class="nc" id="L751">        example.setMissing(i);</span>
      }
    }

<span class="pc bpc" id="L755" title="1 of 2 branches missed.">    if (getClassFlag())</span>
<span class="nc" id="L756">      example.setClassValue(cName);</span>

<span class="fc" id="L758">    return example; </span>
  }

  /**
   * Generate examples for a uniform cluster dataset. 
   * 
   * @param format the dataset format
   * @param numInstances the number of instances to generator
   * @param cl the cluster definition
   * @param cName the class value
   */
  private void generateUniformExamples(
      Instances format, int numInstances, SubspaceClusterDefinition cl, 
      String cName) {

<span class="nc" id="L773">    Instance example = null;</span>
<span class="nc" id="L774">    int numAtts = m_NumAttributes;</span>
<span class="nc bnc" id="L775" title="All 2 branches missed.">    if (getClassFlag()) numAtts++;</span>

<span class="nc" id="L777">    example = new Instance(numAtts);</span>
<span class="nc" id="L778">    example.setDataset(format);</span>
<span class="nc" id="L779">    boolean[] attributes = cl.getAttributes();</span>
<span class="nc" id="L780">    double[] minValue = cl.getMinValue();</span>
<span class="nc" id="L781">    double[] maxValue = cl.getMaxValue();</span>
<span class="nc" id="L782">    double[] diff = new double[minValue.length];</span>

<span class="nc bnc" id="L784" title="All 2 branches missed.">    for (int i = 0; i &lt; minValue.length; i++)</span>
<span class="nc" id="L785">      diff[i] = (maxValue[i] - minValue[i]);</span>

<span class="nc bnc" id="L787" title="All 2 branches missed.">    for (int j = 0; j &lt; numInstances; j++) {</span>
<span class="nc" id="L788">      int num = -1;</span>
<span class="nc bnc" id="L789" title="All 2 branches missed.">      for (int i = 0; i &lt; m_NumAttributes; i++) {</span>
<span class="nc bnc" id="L790" title="All 2 branches missed.">        if (attributes[i]) {</span>
<span class="nc" id="L791">          num++;</span>
<span class="nc" id="L792">          double value = minValue[num] + (diff[num] * (double)((double)j / (double)(numInstances - 1)));</span>
<span class="nc" id="L793">          example.setValue(i, value);</span>
<span class="nc" id="L794">        } </span>
        else {
<span class="nc" id="L796">          example.setMissing(i);</span>
        }
      }
<span class="nc bnc" id="L799" title="All 2 branches missed.">      if (getClassFlag())</span>
<span class="nc" id="L800">        example.setClassValue(cName);</span>
<span class="nc" id="L801">      format.add(example);</span>
    }
<span class="nc" id="L803">  }</span>

  /**
   * Generate examples for a uniform cluster dataset. 
   * 
   * @param format the dataset format
   * @param numInstances the number of instances to generator
   * @param cl the cluster definition
   * @param cName the class value
   */
  private void generateUniformIntegerExamples(
      Instances format, int numInstances, SubspaceClusterDefinition cl, 
      String cName) {

<span class="nc" id="L817">    Instance example = null;</span>
<span class="nc" id="L818">    int numAtts = m_NumAttributes;</span>
<span class="nc bnc" id="L819" title="All 2 branches missed.">    if (getClassFlag()) numAtts++;</span>

<span class="nc" id="L821">    example = new Instance(numAtts);</span>
<span class="nc" id="L822">    example.setDataset(format);</span>
<span class="nc" id="L823">    boolean[] attributes = cl.getAttributes();</span>
<span class="nc" id="L824">    double[] minValue = cl.getMinValue();</span>
<span class="nc" id="L825">    double[] maxValue = cl.getMaxValue();</span>
<span class="nc" id="L826">    int[] minInt = new int[minValue.length];</span>
<span class="nc" id="L827">    int[] maxInt = new int[maxValue.length];</span>
<span class="nc" id="L828">    int[] intValue = new int[maxValue.length];</span>
<span class="nc" id="L829">    int[] numInt = new int[minValue.length];</span>

<span class="nc" id="L831">    int num = 1;</span>
<span class="nc bnc" id="L832" title="All 2 branches missed.">    for (int i = 0; i &lt; minValue.length; i++) {</span>
<span class="nc" id="L833">      minInt[i] = (int)Math.ceil(minValue[i]);</span>
<span class="nc" id="L834">      maxInt[i] = (int)Math.floor(maxValue[i]);</span>
<span class="nc" id="L835">      numInt[i] = (maxInt[i] - minInt[i] + 1);</span>
<span class="nc" id="L836">      num = num * numInt[i];</span>
    }
<span class="nc" id="L838">    int numEach = numInstances / num;</span>
<span class="nc" id="L839">    int rest = numInstances - numEach * num;</span>

    // initialize with smallest values combination
<span class="nc bnc" id="L842" title="All 2 branches missed.">    for (int i = 0; i &lt; m_NumAttributes; i++) {</span>
<span class="nc bnc" id="L843" title="All 2 branches missed.">      if (attributes[i]) {</span>
<span class="nc" id="L844">        example.setValue(i, (double)minInt[i]);</span>
<span class="nc" id="L845">        intValue[i] = minInt[i];</span>
      } 
      else {
<span class="nc" id="L848">        example.setMissing(i);</span>
      }
    }
<span class="nc bnc" id="L851" title="All 2 branches missed.">    if (getClassFlag())</span>
<span class="nc" id="L852">      example.setClassValue(cName);</span>
<span class="nc" id="L853">    int added = 0;</span>
<span class="nc" id="L854">    int attr = 0;</span>
    // do while not added all
    do {
      // add all for one value combination
<span class="nc bnc" id="L858" title="All 2 branches missed.">      for (int k = 0; k &lt; numEach; k++) {</span>
<span class="nc" id="L859">        format.add(example);</span>
<span class="nc" id="L860">        example = (Instance) example.copy();</span>
<span class="nc" id="L861">        added++;</span>
      }
<span class="nc bnc" id="L863" title="All 2 branches missed.">      if (rest &gt; 0) {</span>
<span class="nc" id="L864">        format.add(example);</span>
<span class="nc" id="L865">        example = (Instance) example.copy();</span>
<span class="nc" id="L866">        added++;</span>
<span class="nc" id="L867">        rest--;</span>
      }

<span class="nc bnc" id="L870" title="All 2 branches missed.">      if (added &gt;= numInstances) break;</span>
      // switch to the next value combination
<span class="nc" id="L872">      boolean done = false;</span>
      do {
<span class="nc bnc" id="L874" title="All 4 branches missed.">        if (attributes[attr] &amp;&amp; (intValue[attr] + 1 &lt;= maxInt[attr])) {</span>
<span class="nc" id="L875">          intValue[attr]++;</span>
<span class="nc" id="L876">          done = true;</span>
        } 
        else {
<span class="nc" id="L879">          attr++;</span>
        }
<span class="nc bnc" id="L881" title="All 2 branches missed.">      } while (!done);</span>

<span class="nc" id="L883">      example.setValue(attr, (double)intValue[attr]);</span>
<span class="nc bnc" id="L884" title="All 2 branches missed.">    } while (added &lt; numInstances);</span>
<span class="nc" id="L885">  }</span>

  /**
   * Generate examples for a uniform cluster dataset. 
   * 
   * @param format the dataset format
   * @param numInstances the number of instances to generate
   * @param random the random number generator
   * @param cl the cluster definition
   * @param cName the class value
   */
  private void generateGaussianExamples(
      Instances format, int numInstances, Random random, 
      SubspaceClusterDefinition cl, String cName) {

<span class="nc" id="L900">    boolean makeInteger = cl.isInteger();</span>
<span class="nc" id="L901">    Instance example = null;</span>
<span class="nc" id="L902">    int numAtts = m_NumAttributes;</span>
<span class="nc bnc" id="L903" title="All 2 branches missed.">    if (getClassFlag()) numAtts++;</span>

<span class="nc" id="L905">    example = new Instance(numAtts);</span>
<span class="nc" id="L906">    example.setDataset(format);</span>
<span class="nc" id="L907">    boolean[] attributes = cl.getAttributes();</span>
<span class="nc" id="L908">    double[] meanValue = cl.getMeanValue();</span>
<span class="nc" id="L909">    double[] stddevValue = cl.getStddevValue();</span>

<span class="nc bnc" id="L911" title="All 2 branches missed.">    for (int j = 0; j &lt; numInstances; j++) {</span>
<span class="nc" id="L912">      int num = -1;</span>
<span class="nc bnc" id="L913" title="All 2 branches missed.">      for (int i = 0; i &lt; m_NumAttributes; i++) {</span>
<span class="nc bnc" id="L914" title="All 2 branches missed.">        if (attributes[i]) {</span>
<span class="nc" id="L915">          num++;</span>
<span class="nc" id="L916">          double value = meanValue[num] + (random.nextGaussian() * stddevValue[num]);</span>
<span class="nc bnc" id="L917" title="All 2 branches missed.">          if (makeInteger)</span>
<span class="nc" id="L918">            value = Math.round(value);</span>
<span class="nc" id="L919">          example.setValue(i, value);</span>
<span class="nc" id="L920">        } </span>
        else {
<span class="nc" id="L922">          example.setMissing(i);</span>
        }
      }
<span class="nc bnc" id="L925" title="All 2 branches missed.">      if (getClassFlag())</span>
<span class="nc" id="L926">        example.setClassValue(cName);</span>
<span class="nc" id="L927">      format.add(example);</span>
    }
<span class="nc" id="L929">  }</span>

  /**
   * Compiles documentation about the data generation after
   * the generation process
   *
   * @return string with additional information about generated dataset
   * @throws Exception no input structure has been defined
   */
  public String generateFinished() throws Exception {
<span class="fc" id="L939">    return &quot;&quot;;</span>
  }

  /**
   * Compiles documentation about the data generation before
   * the generation process
   *
   * @return string with additional information 
   */
  public String generateStart() {
<span class="fc" id="L949">    StringBuffer docu = new StringBuffer();</span>

<span class="fc" id="L951">    int sumInst = 0;</span>
<span class="fc bfc" id="L952" title="All 2 branches covered.">    for (int cNum = 0; cNum &lt; getClusters().length; cNum++) {</span>
<span class="fc" id="L953">      SubspaceClusterDefinition cl  = (SubspaceClusterDefinition) getClusters()[cNum];</span>
<span class="fc" id="L954">      docu.append(&quot;%\n&quot;);</span>
<span class="fc" id="L955">      docu.append(&quot;% Cluster: c&quot;+ cNum + &quot;   &quot;);</span>
<span class="pc bpc" id="L956" title="3 of 4 branches missed.">      switch (cl.getClusterType().getSelectedTag().getID()) {</span>
        case UNIFORM_RANDOM: 
<span class="fc" id="L958">          docu.append(&quot;Uniform Random&quot;);</span>
<span class="fc" id="L959">          break;</span>
        case TOTAL_UNIFORM: 
<span class="nc" id="L961">          docu.append(&quot;Total Random&quot;);</span>
<span class="nc" id="L962">          break;</span>
        case GAUSSIAN: 
<span class="nc" id="L964">          docu.append(&quot;Gaussian&quot;);</span>
          break;
      }
<span class="pc bpc" id="L967" title="1 of 2 branches missed.">      if (cl.isInteger()) {</span>
<span class="nc" id="L968">        docu.append(&quot; / INTEGER&quot;);</span>
      }

<span class="fc" id="L971">      docu.append(&quot;\n% ----------------------------------------------\n&quot;);</span>
<span class="fc" id="L972">      docu.append(&quot;%&quot;+cl.attributesToString());</span>

<span class="fc" id="L974">      docu.append(&quot;\n% Number of Instances:            &quot;  + cl.getInstNums() + &quot;\n&quot;);</span>
<span class="fc" id="L975">      docu.append(  &quot;% Generated Number of Instances:  &quot;  + cl.getNumInstances() + &quot;\n&quot;);</span>
<span class="fc" id="L976">      sumInst += cl.getNumInstances();</span>
        }
<span class="fc" id="L978">    docu.append(&quot;%\n% ----------------------------------------------\n&quot;); </span>
<span class="fc" id="L979">    docu.append(&quot;% Total Number of Instances: &quot; + sumInst + &quot;\n&quot;);</span>
<span class="fc" id="L980">    docu.append(&quot;%                            in &quot; + getClusters().length + &quot; Cluster(s)\n%&quot;);</span>

<span class="fc" id="L982">    return docu.toString();</span>
  }
  
  /**
   * Returns the revision string.
   * 
   * @return		the revision
   */
  public String getRevision() {
<span class="nc" id="L991">    return RevisionUtils.extract(&quot;$Revision: 1.5 $&quot;);</span>
  }

  /**
   * Main method for testing this class.
   *
   * @param args should contain arguments for the data producer: 
   */
  public static void main(String[] args) {
<span class="nc" id="L1000">    runDataGenerator(new SubspaceCluster(), args);</span>
<span class="nc" id="L1001">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>
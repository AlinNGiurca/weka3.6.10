<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>BIRCHCluster.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCoverage analysis of project &quot;Weka-3.6.10&quot; (powered by JaCoCo from EclEmma)</a> &gt; <a href="index.source.html" class="el_package">weka.datagenerators.clusterers</a> &gt; <span class="el_source">BIRCHCluster.java</span></div><h1>BIRCHCluster.java</h1><pre class="source lang-java linenums">/*
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation; either version 2 of the License, or
 *    (at your option) any later version.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not, write to the Free Software
 *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/*
 *    BIRCHCluster.java
 *    Copyright (C) 2001 University of Waikato, Hamilton, New Zealand
 *
 */

package weka.datagenerators.clusterers;

import weka.core.Attribute;
import weka.core.FastVector;
import weka.core.Instance;
import weka.core.Instances;
import weka.core.Option;
import weka.core.RevisionHandler;
import weka.core.RevisionUtils;
import weka.core.SelectedTag;
import weka.core.Tag;
import weka.core.TechnicalInformation;
import weka.core.TechnicalInformationHandler;
import weka.core.Utils;
import weka.core.TechnicalInformation.Field;
import weka.core.TechnicalInformation.Type;
import weka.datagenerators.ClusterGenerator;

import java.io.Serializable;
import java.util.Enumeration;
import java.util.Random;
import java.util.Vector;

/**
 &lt;!-- globalinfo-start --&gt;
 * Cluster data generator designed for the BIRCH System&lt;br/&gt;
 * &lt;br/&gt;
 * Dataset is generated with instances in K clusters.&lt;br/&gt;
 * Instances are 2-d data points.&lt;br/&gt;
 * Each cluster is characterized by the number of data points in itits radius and its center. The location of the cluster centers isdetermined by the pattern parameter. Three patterns are currentlysupported grid, sine and random.&lt;br/&gt;
 * &lt;br/&gt;
 * For more information refer to:&lt;br/&gt;
 * &lt;br/&gt;
 * Tian Zhang, Raghu Ramakrishnan, Miron Livny: BIRCH: An Efficient Data Clustering Method for Very Large Databases. In: ACM SIGMOD International Conference on Management of Data, 103-114, 1996.
 * &lt;p/&gt;
 &lt;!-- globalinfo-end --&gt;
 *
 &lt;!-- technical-bibtex-start --&gt;
 * BibTeX:
 * &lt;pre&gt;
 * &amp;#64;inproceedings{Zhang1996,
 *    author = {Tian Zhang and Raghu Ramakrishnan and Miron Livny},
 *    booktitle = {ACM SIGMOD International Conference on Management of Data},
 *    pages = {103-114},
 *    publisher = {ACM Press},
 *    title = {BIRCH: An Efficient Data Clustering Method for Very Large Databases},
 *    year = {1996}
 * }
 * &lt;/pre&gt;
 * &lt;p/&gt;
 &lt;!-- technical-bibtex-end --&gt;
 * 
 &lt;!-- options-start --&gt;
 * Valid options are: &lt;p/&gt;
 * 
 * &lt;pre&gt; -h
 *  Prints this help.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -o &amp;lt;file&amp;gt;
 *  The name of the output file, otherwise the generated data is
 *  printed to stdout.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -r &amp;lt;name&amp;gt;
 *  The name of the relation.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -d
 *  Whether to print debug informations.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -S
 *  The seed for random function (default 1)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -a &amp;lt;num&amp;gt;
 *  The number of attributes (default 10).&lt;/pre&gt;
 * 
 * &lt;pre&gt; -c
 *  Class Flag, if set, the cluster is listed in extra attribute.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -b &amp;lt;range&amp;gt;
 *  The indices for boolean attributes.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -m &amp;lt;range&amp;gt;
 *  The indices for nominal attributes.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -k &amp;lt;num&amp;gt;
 *  The number of clusters (default 4)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -G
 *  Set pattern to grid (default is random).
 *  This flag cannot be used at the same time as flag I.
 *  The pattern is random, if neither flag G nor flag I is set.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -I
 *  Set pattern to sine (default is random).
 *  This flag cannot be used at the same time as flag I.
 *  The pattern is random, if neither flag G nor flag I is set.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -N &amp;lt;num&amp;gt;..&amp;lt;num&amp;gt;
 *  The range of number of instances per cluster (default 1..50).
 *  Lower number must be between 0 and 2500,
 *  upper number must be between 50 and 2500.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -R &amp;lt;num&amp;gt;..&amp;lt;num&amp;gt;
 *  The range of radius per cluster (default 0.1..1.4142135623730951).
 *  Lower number must be between 0 and SQRT(2), 
 *  upper number must be between SQRT(2) and SQRT(32).&lt;/pre&gt;
 * 
 * &lt;pre&gt; -M &amp;lt;num&amp;gt;
 *  The distance multiplier (default 4.0).&lt;/pre&gt;
 * 
 * &lt;pre&gt; -C &amp;lt;num&amp;gt;
 *  The number of cycles (default 4).&lt;/pre&gt;
 * 
 * &lt;pre&gt; -O
 *  Flag for input order is ORDERED. If flag is not set then 
 *  input order is RANDOMIZED. RANDOMIZED is currently not 
 *  implemented, therefore is the input order always ORDERED.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -P &amp;lt;num&amp;gt;
 *  The noise rate in percent (default 0.0).
 *  Can be between 0% and 30%. (Remark: The original 
 *  algorithm only allows noise up to 10%.)&lt;/pre&gt;
 * 
 &lt;!-- options-end --&gt;
 *
 * @author Gabi Schmidberger (gabi@cs.waikato.ac.nz)
 * @author FracPete (fracpete at waikato dot ac dot nz)
 * @version $Revision: 1.8 $ 
 */
public class BIRCHCluster 
  extends ClusterGenerator
  implements TechnicalInformationHandler {

  /** for serialization */
  static final long serialVersionUID = -334820527230755027L;
  
  /** Number of Clusters the dataset should have */
  protected int m_NumClusters;

  /** minimal number of instances per cluster (option N)*/ 
  private int m_MinInstNum;
  
  /** maximal number of instances per cluster (option N)*/ 
  private int m_MaxInstNum;
  
  /** minimum radius (option R)*/ 
  private double m_MinRadius;
  
  /** maximum radius (option R)*/ 
  private double m_MaxRadius;
  
  /**  Constant set for choice of pattern. (option G)*/
  public static final int GRID = 0;
  /**  Constant set for choice of pattern. (option I)*/
  public static final int SINE = 1;
  /**  Constant set for choice of pattern. (default)*/
  public static final int RANDOM = 2;
  /** the pattern tags */
<span class="fc" id="L180">  public static final Tag[] TAGS_PATTERN = {</span>
    new Tag(GRID,   &quot;Grid&quot;),
    new Tag(SINE,   &quot;Sine&quot;),
    new Tag(RANDOM, &quot;Random&quot;)
  };
  
  /** pattern (changed with options G or S)*/ 
  private int m_Pattern;
  
  /** distance multiplier (option M)*/
  private double m_DistMult;

  /** number of cycles (option C)*/
  private int m_NumCycles;

  /**  Constant set for input order (option O)*/
  public static final int ORDERED = 0;
  /**  Constant set for input order (default)*/
  public static final int RANDOMIZED = 1;
  /** the input order tags */
<span class="fc" id="L200">  public static final Tag[] TAGS_INPUTORDER = {</span>
    new Tag(ORDERED,    &quot;ordered&quot;),
    new Tag(RANDOMIZED, &quot;randomized&quot;)
  };

  /** input order (changed with option O)*/ 
  private int m_InputOrder;

  /** noise rate in percent (option P,  between 0 and 30)*/ 
  private double m_NoiseRate;

  /** cluster list */
  private FastVector m_ClusterList;

  // following are used for pattern is GRID
  /** grid size*/
  private int m_GridSize;

  /** grid width*/
  private double m_GridWidth;
  
  /**
   * class to represent cluster
   */
  private class Cluster 
    implements Serializable, RevisionHandler {

    /** for serialization */
    static final long serialVersionUID = -8336901069823498140L;    
    
    /** number of instances for this cluster */
    private int m_InstNum;

    /** radius of cluster
     *   variance is radius ** 2 / 2 */
    private double m_Radius;

    /** center of cluster = array of Double values */
    private double[] m_Center;

    /**
     * Constructor, used for pattern = RANDOM
     *
     * @param instNum the number of instances
     * @param radius radius of the cluster
     * @param random the random number generator to use 
     */
<span class="fc" id="L247">    private Cluster(int instNum, double radius, Random random) {</span>
<span class="fc" id="L248">      m_InstNum = instNum;</span>
<span class="fc" id="L249">      m_Radius = radius;</span>
<span class="fc" id="L250">      m_Center = new double[getNumAttributes()];</span>
<span class="fc bfc" id="L251" title="All 2 branches covered.">      for (int i = 0; i &lt; getNumAttributes(); i++) {</span>
<span class="fc" id="L252">	m_Center[i] = random.nextDouble() * (double) m_NumClusters;</span>
      }
<span class="fc" id="L254">    }</span>

    /**
     * Constructor, used for pattern = GRID
     *
     * @param instNum the number of instances
     * @param radius radius of the cluster
     * @param gridVector vector for grid positions
     * @param gridWidth factor for grid position
     */
      // center is defined in the constructor of cluster
    private Cluster(int instNum,
		    double radius,
		    int[] gridVector,
<span class="nc" id="L268">		    double gridWidth) {</span>
<span class="nc" id="L269">      m_InstNum = instNum;</span>
<span class="nc" id="L270">      m_Radius = radius;</span>
<span class="nc" id="L271">      m_Center = new double[getNumAttributes()];</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">      for (int i = 0; i &lt; getNumAttributes(); i++) {</span>
<span class="nc" id="L273">	m_Center[i] = ((double) gridVector[i] + 1.0) * gridWidth;</span>
      }
      
<span class="nc" id="L276">    }</span>
   
    /**
     * returns the number of instances
     * 
     * @return the number of instances
     */
    private int getInstNum() { 
<span class="fc" id="L284">      return m_InstNum; </span>
    }
    
    /**
     * returns the radius
     * 
     * @return the radius
     */
    private double getRadius() { 
<span class="nc" id="L293">      return m_Radius; </span>
    }
    
    /**
     * returns the variance
     * 
     * @return the variance
     */
    private double getVariance() { 
<span class="nc" id="L302">      return Math.pow(m_Radius, 2.0) / 2.0; </span>
    }
    
    /**
     * returns the standard deviation
     * 
     * @return the standard deviation
     */
    private double getStdDev() { 
<span class="fc" id="L311">      return (m_Radius / Math.pow(2.0, 0.5)); </span>
    }
    
    /**
     * returns the centers
     * 
     * @return the centers
     */
    private double[] getCenter() { 
<span class="fc" id="L320">      return m_Center; </span>
    }
    
    /**
     * returns the center value for a given dimension
     * 
     * @param dimension the dimension to return the center for
     * @return the center value for the given dimension
     * @throws Exception if dimension invalid
     */
    private double getCenterValue(int dimension) throws Exception {
<span class="nc bnc" id="L331" title="All 2 branches missed.">      if (dimension &gt;= m_Center.length)</span>
<span class="nc" id="L332">	throw new Exception(&quot;Current system has only &quot; +</span>
			    m_Center.length + &quot; dimensions.&quot;);
<span class="nc" id="L334">      return m_Center[dimension];</span>
    }
    
    /**
     * Returns the revision string.
     * 
     * @return		the revision
     */
    public String getRevision() {
<span class="nc" id="L343">      return RevisionUtils.extract(&quot;$Revision: 1.8 $&quot;);</span>
    }
  } // end class Cluster

  /**
   * class to represent Vector for placement of the center in space
   */
  private class GridVector 
    implements Serializable, RevisionHandler {

    /** for serialization */
    static final long serialVersionUID = -1900309948991039522L;
    
    /** array of integer */
    private int[] m_GridVector;

    /**  one higher then the highest possible integer value
     *  in any of the integers in the gridvector */
    private int m_Base;

    /** size of vector */
    private int m_Size;

    /**
     * Constructor
     *
     * @param numDim number of dimensions = number of attributes
     * @param base is one higher then the highest possible integer value
     * in any of the integers in the gridvector
     */
<span class="nc" id="L373">    private GridVector(int numDim, int base) {</span>
<span class="nc" id="L374">      m_Size = numDim;</span>
<span class="nc" id="L375">      m_Base = base;</span>
<span class="nc" id="L376">      m_GridVector = new int [numDim];</span>
<span class="nc bnc" id="L377" title="All 2 branches missed.">      for (int i = 0; i &lt; numDim; i++)</span>
<span class="nc" id="L378">	m_GridVector[i] = 0;</span>
<span class="nc" id="L379">    }</span>

    /**
     * returns the integer array
     *
     * @return the integer array
     */
    private int[] getGridVector() {
<span class="nc" id="L387">      return m_GridVector;</span>
    }

    /**
     * Overflow has occurred when integer is zero.
     *
     *@param digit the input integer
     *@return true if digit is 0
     */
    private boolean overflow(int digit) {
<span class="nc bnc" id="L397" title="All 2 branches missed.">      return (digit == 0);</span>
    }

    /**
     * Adds one to integer and sets to zero, if new value was
     * equal m_Base.
     *
     *@param digit the input integer
     *@return new integer object
     */
    private int addOne(int digit) {
<span class="nc" id="L408">      int value = digit + 1;</span>
<span class="nc bnc" id="L409" title="All 2 branches missed.">      if (value &gt;= m_Base) value = 0;</span>
<span class="nc" id="L410">      return value;</span>
    }

    /**
     * add 1 to vector
     */
    private void addOne() {
<span class="nc" id="L417">      m_GridVector[0] = addOne(m_GridVector[0]);</span>
<span class="nc" id="L418">      int i = 1;</span>
<span class="nc bnc" id="L419" title="All 4 branches missed.">      while (overflow(m_GridVector[i - 1]) &amp;&amp; i &lt; m_Size) {</span>
<span class="nc" id="L420">        m_GridVector[i] = addOne(m_GridVector[i]);</span>
<span class="nc" id="L421">	i++;</span>
      }
	
<span class="nc" id="L424">    }</span>
    
    /**
     * Returns the revision string.
     * 
     * @return		the revision
     */
    public String getRevision() {
<span class="nc" id="L432">      return RevisionUtils.extract(&quot;$Revision: 1.8 $&quot;);</span>
    }
  } // end class GridVector
  
  /**
   * initializes the generator with default values
   */
  public BIRCHCluster() {
<span class="fc" id="L440">    super();</span>

<span class="fc" id="L442">    setNumClusters(defaultNumClusters());</span>
<span class="fc" id="L443">    setMinInstNum(defaultMinInstNum());</span>
<span class="fc" id="L444">    setMaxInstNum(defaultMaxInstNum());</span>
<span class="fc" id="L445">    setMinRadius(defaultMinRadius());</span>
<span class="fc" id="L446">    setMaxRadius(defaultMaxRadius());</span>
<span class="fc" id="L447">    setPattern(defaultPattern());</span>
<span class="fc" id="L448">    setDistMult(defaultDistMult());</span>
<span class="fc" id="L449">    setNumCycles(defaultNumCycles());</span>
<span class="fc" id="L450">    setInputOrder(defaultInputOrder());</span>
<span class="fc" id="L451">    setNoiseRate(defaultNoiseRate());</span>
<span class="fc" id="L452">  }</span>
  
  /**
   * Returns a string describing this data generator.
   *
   * @return a description of the data generator suitable for
   * displaying in the explorer/experimenter gui
   */
  public String globalInfo() {
<span class="nc" id="L461">    return </span>
        &quot;Cluster data generator designed for the BIRCH System\n\n&quot;
      + &quot;Dataset is generated with instances in K clusters.\n&quot;
      + &quot;Instances are 2-d data points.\n&quot;
      + &quot;Each cluster is characterized by the number of data points in it&quot;
      + &quot;its radius and its center. The location of the cluster centers is&quot;
      + &quot;determined by the pattern parameter. Three patterns are currently&quot;
      + &quot;supported grid, sine and random.\n\n&quot;
      + &quot;For more information refer to:\n\n&quot;
<span class="nc" id="L470">      + getTechnicalInformation().toString();</span>
  }

  /**
   * Returns an instance of a TechnicalInformation object, containing 
   * detailed information about the technical background of this class,
   * e.g., paper reference or book this class is based on.
   * 
   * @return the technical information about this class
   */
  public TechnicalInformation getTechnicalInformation() {
    TechnicalInformation 	result;
    
<span class="nc" id="L483">    result = new TechnicalInformation(Type.INPROCEEDINGS);</span>
<span class="nc" id="L484">    result.setValue(Field.AUTHOR, &quot;Tian Zhang and Raghu Ramakrishnan and Miron Livny&quot;);</span>
<span class="nc" id="L485">    result.setValue(Field.TITLE, &quot;BIRCH: An Efficient Data Clustering Method for Very Large Databases&quot;);</span>
<span class="nc" id="L486">    result.setValue(Field.BOOKTITLE, &quot;ACM SIGMOD International Conference on Management of Data&quot;);</span>
<span class="nc" id="L487">    result.setValue(Field.YEAR, &quot;1996&quot;);</span>
<span class="nc" id="L488">    result.setValue(Field.PAGES, &quot;103-114&quot;);</span>
<span class="nc" id="L489">    result.setValue(Field.PUBLISHER, &quot;ACM Press&quot;);</span>
    
<span class="nc" id="L491">    return result;</span>
  }

  /**
   * Returns an enumeration describing the available options.
   *
   * @return an enumeration of all the available options
   */
  public Enumeration listOptions() {
<span class="fc" id="L500">    Vector result = enumToVector(super.listOptions());</span>

<span class="fc" id="L502">    result.addElement(new Option(</span>
          &quot;\tThe number of clusters (default &quot;
<span class="fc" id="L504">          + defaultNumClusters() + &quot;)&quot;,</span>
          &quot;k&quot;, 1, &quot;-k &lt;num&gt;&quot;));

<span class="fc" id="L507">    result.addElement(new Option(</span>
          &quot;\tSet pattern to grid (default is random).\n&quot;
	  + &quot;\tThis flag cannot be used at the same time as flag I.\n&quot;
	  + &quot;\tThe pattern is random, if neither flag G nor flag I is set.&quot;,
          &quot;G&quot;, 0, &quot;-G&quot;));

<span class="fc" id="L513">    result.addElement(new Option(</span>
          &quot;\tSet pattern to sine (default is random).\n&quot;
	  + &quot;\tThis flag cannot be used at the same time as flag I.\n&quot;
	  + &quot;\tThe pattern is random, if neither flag G nor flag I is set.&quot;,
          &quot;I&quot;, 0, &quot;-I&quot;));

<span class="fc" id="L519">    result.addElement(new Option(</span>
          &quot;\tThe range of number of instances per cluster (default &quot;
<span class="fc" id="L521">          + defaultMinInstNum() + &quot;..&quot; + defaultMaxInstNum() + &quot;).\n&quot;</span>
          + &quot;\tLower number must be between 0 and 2500,\n&quot;
          + &quot;\tupper number must be between 50 and 2500.&quot;,
          &quot;N&quot;, 1, &quot;-N &lt;num&gt;..&lt;num&gt;&quot;));

<span class="fc" id="L526">    result.addElement(new Option(</span>
          &quot;\tThe range of radius per cluster (default &quot;
<span class="fc" id="L528">          + defaultMinRadius() + &quot;..&quot; + defaultMaxRadius() + &quot;).\n&quot;</span>
          + &quot;\tLower number must be between 0 and SQRT(2), \n&quot;
          + &quot;\tupper number must be between SQRT(2) and SQRT(32).&quot;,
          &quot;R&quot;, 1, &quot;-R &lt;num&gt;..&lt;num&gt;&quot;));

<span class="fc" id="L533">    result.addElement(new Option(</span>
          &quot;\tThe distance multiplier (default &quot; 
<span class="fc" id="L535">          + defaultDistMult() + &quot;).&quot;,</span>
          &quot;M&quot;, 1, &quot;-M &lt;num&gt;&quot;));

<span class="fc" id="L538">    result.addElement(new Option(</span>
          &quot;\tThe number of cycles (default &quot;
<span class="fc" id="L540">          + defaultNumCycles() + &quot;).&quot;,</span>
          &quot;C&quot;, 1, &quot;-C &lt;num&gt;&quot;));

<span class="fc" id="L543">    result.addElement(new Option(</span>
  	  &quot;\tFlag for input order is ORDERED. If flag is not set then \n&quot;
	  + &quot;\tinput order is RANDOMIZED. RANDOMIZED is currently not \n&quot;
	  + &quot;\timplemented, therefore is the input order always ORDERED.&quot;,
          &quot;O&quot;, 0, &quot;-O&quot;));

<span class="fc" id="L549">    result.addElement(new Option(</span>
          &quot;\tThe noise rate in percent (default &quot; 
<span class="fc" id="L551">          + defaultNoiseRate() + &quot;).\n&quot;</span>
          + &quot;\tCan be between 0% and 30%. (Remark: The original \n&quot;
          + &quot;\talgorithm only allows noise up to 10%.)&quot;,
          &quot;P&quot;, 1, &quot;-P &lt;num&gt;&quot;));

<span class="fc" id="L556">    return result.elements();</span>
  }
  
  /**
   * Parses a list of options for this object. &lt;p/&gt;
   *
   &lt;!-- options-start --&gt;
   * Valid options are: &lt;p/&gt;
   * 
   * &lt;pre&gt; -h
   *  Prints this help.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -o &amp;lt;file&amp;gt;
   *  The name of the output file, otherwise the generated data is
   *  printed to stdout.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -r &amp;lt;name&amp;gt;
   *  The name of the relation.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -d
   *  Whether to print debug informations.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -S
   *  The seed for random function (default 1)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -a &amp;lt;num&amp;gt;
   *  The number of attributes (default 10).&lt;/pre&gt;
   * 
   * &lt;pre&gt; -c
   *  Class Flag, if set, the cluster is listed in extra attribute.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -b &amp;lt;range&amp;gt;
   *  The indices for boolean attributes.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -m &amp;lt;range&amp;gt;
   *  The indices for nominal attributes.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -k &amp;lt;num&amp;gt;
   *  The number of clusters (default 4)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -G
   *  Set pattern to grid (default is random).
   *  This flag cannot be used at the same time as flag I.
   *  The pattern is random, if neither flag G nor flag I is set.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -I
   *  Set pattern to sine (default is random).
   *  This flag cannot be used at the same time as flag I.
   *  The pattern is random, if neither flag G nor flag I is set.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -N &amp;lt;num&amp;gt;..&amp;lt;num&amp;gt;
   *  The range of number of instances per cluster (default 1..50).
   *  Lower number must be between 0 and 2500,
   *  upper number must be between 50 and 2500.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -R &amp;lt;num&amp;gt;..&amp;lt;num&amp;gt;
   *  The range of radius per cluster (default 0.1..1.4142135623730951).
   *  Lower number must be between 0 and SQRT(2), 
   *  upper number must be between SQRT(2) and SQRT(32).&lt;/pre&gt;
   * 
   * &lt;pre&gt; -M &amp;lt;num&amp;gt;
   *  The distance multiplier (default 4.0).&lt;/pre&gt;
   * 
   * &lt;pre&gt; -C &amp;lt;num&amp;gt;
   *  The number of cycles (default 4).&lt;/pre&gt;
   * 
   * &lt;pre&gt; -O
   *  Flag for input order is ORDERED. If flag is not set then 
   *  input order is RANDOMIZED. RANDOMIZED is currently not 
   *  implemented, therefore is the input order always ORDERED.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -P &amp;lt;num&amp;gt;
   *  The noise rate in percent (default 0.0).
   *  Can be between 0% and 30%. (Remark: The original 
   *  algorithm only allows noise up to 10%.)&lt;/pre&gt;
   * 
   &lt;!-- options-end --&gt;
   *
   * @param options the list of options as an array of strings
   * @throws Exception if an option is not supported
   */
  public void setOptions(String[] options) throws Exception {
    String        tmpStr;
   
<span class="fc" id="L640">    super.setOptions(options);</span>

<span class="fc" id="L642">    tmpStr = Utils.getOption('k', options);</span>
<span class="fc bfc" id="L643" title="All 2 branches covered.">    if (tmpStr.length() != 0)</span>
<span class="fc" id="L644">      setNumClusters(Integer.parseInt(tmpStr));</span>
    else
<span class="fc" id="L646">      setNumClusters(defaultNumClusters());</span>

<span class="fc" id="L648">    tmpStr = Utils.getOption('N', options);</span>
<span class="fc bfc" id="L649" title="All 2 branches covered.">    if (tmpStr.length() != 0)</span>
<span class="fc" id="L650">      setInstNums(tmpStr);</span>
    else
<span class="fc" id="L652">      setInstNums(defaultMinInstNum() + &quot;..&quot; + defaultMaxInstNum());</span>
    
<span class="fc" id="L654">    tmpStr = Utils.getOption('R', options);</span>
<span class="fc bfc" id="L655" title="All 2 branches covered.">    if (tmpStr.length() != 0)</span>
<span class="fc" id="L656">      setRadiuses(tmpStr);</span>
    else
<span class="fc" id="L658">      setRadiuses(defaultMinRadius() + &quot;..&quot; + defaultMaxRadius());</span>

<span class="fc" id="L660">    boolean grid = Utils.getFlag('G', options);</span>
<span class="fc" id="L661">    boolean sine = Utils.getFlag('I', options);</span>

<span class="pc bpc" id="L663" title="3 of 4 branches missed.">    if (grid &amp;&amp; sine)</span>
<span class="nc" id="L664">      throw new Exception(&quot;Flags -G and -I can only be set mutually exclusiv.&quot;);</span>

<span class="fc" id="L666">    setPattern(new SelectedTag(RANDOM, TAGS_PATTERN));</span>
<span class="pc bpc" id="L667" title="1 of 2 branches missed.">    if (grid)</span>
<span class="nc" id="L668">      setPattern(new SelectedTag(GRID, TAGS_PATTERN));</span>
<span class="pc bpc" id="L669" title="1 of 2 branches missed.">    if (sine)</span>
<span class="nc" id="L670">      setPattern(new SelectedTag(SINE, TAGS_PATTERN));</span>

<span class="fc" id="L672">    tmpStr= Utils.getOption('M', options);</span>
<span class="pc bpc" id="L673" title="1 of 2 branches missed.">    if (tmpStr.length() != 0) {</span>
<span class="nc bnc" id="L674" title="All 2 branches missed.">      if (!grid)</span>
<span class="nc" id="L675">	throw new Exception(&quot;Option M can only be used with GRID pattern.&quot;);</span>
<span class="nc" id="L676">      setDistMult(Double.parseDouble(tmpStr));</span>
    }
    else {
<span class="fc" id="L679">      setDistMult(defaultDistMult());</span>
    }

<span class="fc" id="L682">    tmpStr = Utils.getOption('C', options);</span>
<span class="pc bpc" id="L683" title="1 of 2 branches missed.">    if (tmpStr.length() != 0) {</span>
<span class="nc bnc" id="L684" title="All 2 branches missed.">      if (!sine)</span>
<span class="nc" id="L685">	throw new Exception(&quot;Option C can only be used with SINE pattern.&quot;);</span>
<span class="nc" id="L686">      setNumCycles(Integer.parseInt(tmpStr));</span>
    } 
    else {
<span class="fc" id="L689">      setNumCycles(defaultNumCycles());</span>
    }

<span class="fc bfc" id="L692" title="All 2 branches covered.">    if (Utils.getFlag('O', options))</span>
<span class="fc" id="L693">      setInputOrder(new SelectedTag(ORDERED, TAGS_INPUTORDER));</span>
    else
<span class="fc" id="L695">      setInputOrder(defaultInputOrder());</span>

<span class="fc" id="L697">    tmpStr = Utils.getOption('P', options);</span>
<span class="fc bfc" id="L698" title="All 2 branches covered.">    if (tmpStr.length() != 0)</span>
<span class="fc" id="L699">      setNoiseRate(Double.parseDouble(tmpStr));</span>
    else
<span class="fc" id="L701">      setNoiseRate(defaultNoiseRate());</span>
<span class="fc" id="L702">  }</span>

  /**
   * Gets the current settings of the datagenerator BIRCHCluster.
   *
   * @return an array of strings suitable for passing to setOptions
   */
  public String[] getOptions() {
    Vector        result;
    String[]      options;
    int           i;
    
<span class="fc" id="L714">    result  = new Vector();</span>
<span class="fc" id="L715">    options = super.getOptions();</span>
<span class="fc bfc" id="L716" title="All 2 branches covered.">    for (i = 0; i &lt; options.length; i++)</span>
<span class="fc" id="L717">      result.add(options[i]);</span>
    
<span class="fc" id="L719">    result.add(&quot;-k&quot;);</span>
<span class="fc" id="L720">    result.add(&quot;&quot; + getNumClusters());</span>
    
<span class="fc" id="L722">    result.add(&quot;-N&quot;); </span>
<span class="fc" id="L723">    result.add(&quot;&quot; + getInstNums());</span>

<span class="fc" id="L725">    result.add(&quot;-R&quot;); </span>
<span class="fc" id="L726">    result.add(&quot;&quot; + getRadiuses());</span>

<span class="pc bpc" id="L728" title="1 of 2 branches missed.">    if (m_Pattern == GRID) {</span>
<span class="nc" id="L729">      result.add(&quot;-G&quot;);</span>
      
<span class="nc" id="L731">      result.add(&quot;-M&quot;); </span>
<span class="nc" id="L732">      result.add(&quot;&quot; + getDistMult());</span>
    }

<span class="pc bpc" id="L735" title="1 of 2 branches missed.">    if (m_Pattern == SINE) {</span>
<span class="nc" id="L736">      result.add(&quot;-I&quot;);</span>
      
<span class="nc" id="L738">      result.add(&quot;-C&quot;); </span>
<span class="nc" id="L739">      result.add(&quot;&quot; + getNumCycles());</span>
    }

<span class="pc bpc" id="L742" title="1 of 2 branches missed.">    if (getOrderedFlag())</span>
<span class="fc" id="L743">      result.add(&quot;-O&quot;);</span>

<span class="fc" id="L745">    result.add(&quot;-P&quot;); </span>
<span class="fc" id="L746">    result.add(&quot;&quot; + getNoiseRate());</span>
    
<span class="fc" id="L748">    return (String[]) result.toArray(new String[result.size()]);</span>
  }

  /**
   * returns the default number of clusters
   * 
   * @return the default number of clusters
   */
  protected int defaultNumClusters() {
<span class="fc" id="L757">    return 4;</span>
  }

  /**
   * Sets the number of clusters the dataset should have.
   * @param numClusters the new number of clusters
   */
  public void setNumClusters(int numClusters) { 
<span class="fc" id="L765">    m_NumClusters = numClusters; </span>
<span class="fc" id="L766">  }</span>

  /**
   * Gets the number of clusters the dataset should have.
   * @return the number of clusters the dataset should have
   */
  public int getNumClusters() { 
<span class="fc" id="L773">    return m_NumClusters; </span>
  }
  
  /**
   * Returns the tip text for this property
   * 
   * @return tip text for this property suitable for
   *         displaying in the explorer/experimenter gui
   */
  public String numClustersTipText() {
<span class="nc" id="L783">    return &quot;The number of clusters to generate.&quot;;</span>
  }

  /**
   * Sets the upper and lower boundary for instances per cluster.
   *
   * @param fromTo  the string containing the upper and lower boundary for
   *                instances per cluster separated by ..
   */
  protected void setInstNums(String fromTo) {
<span class="fc" id="L793">    int i = fromTo.indexOf(&quot;..&quot;);</span>
<span class="fc" id="L794">    String from = fromTo.substring(0, i);</span>
<span class="fc" id="L795">    setMinInstNum(Integer.parseInt(from));</span>
<span class="fc" id="L796">    String to = fromTo.substring(i + 2, fromTo.length());</span>
<span class="fc" id="L797">    setMaxInstNum(Integer.parseInt(to));</span>
<span class="fc" id="L798">  }</span>
  
  /**
   * Gets the upper and lower boundary for instances per cluster.
   *
   * @return the string containing the upper and lower boundary for
   * instances per cluster separated by ..
   */
  protected String getInstNums() {
<span class="fc" id="L807">    String fromTo = &quot;&quot; </span>
<span class="fc" id="L808">                    + getMinInstNum() + &quot;..&quot;</span>
<span class="fc" id="L809">                    + getMaxInstNum();</span>
<span class="fc" id="L810">    return fromTo;</span>
  }
  
  /**
   * Returns the tip text for this property
   * 
   * @return tip text for this property suitable for
   *         displaying in the explorer/experimenter gui
   */
  protected String instNumsTipText() {
<span class="nc" id="L820">    return &quot;The upper and lowet boundary for instances per cluster.&quot;;</span>
  }

  /**
   * returns the default min number of instances
   * 
   * @return the default min number of instances
   */
  protected int defaultMinInstNum() {
<span class="fc" id="L829">    return 1;</span>
  }

  /**
   * Gets the lower boundary for instances per cluster.
   *
   * @return the the lower boundary for instances per cluster
   */
  public int getMinInstNum() { 
<span class="fc" id="L838">    return m_MinInstNum; </span>
  }
  
  /**
   * Sets the lower boundary for instances per cluster.
   *
   * @param newMinInstNum new lower boundary for instances per cluster
   */
  public void setMinInstNum(int newMinInstNum) {
<span class="fc" id="L847">    m_MinInstNum = newMinInstNum;</span>
<span class="fc" id="L848">  }</span>
  
  /**
   * Returns the tip text for this property
   * 
   * @return tip text for this property suitable for
   *         displaying in the explorer/experimenter gui
   */
  public String minInstNumTipText() {
<span class="nc" id="L857">    return &quot;The lower boundary for instances per cluster.&quot;;</span>
  }

  /**
   * returns the default max number of instances
   * 
   * @return the default max number of instances
   */
  protected int defaultMaxInstNum() {
<span class="fc" id="L866">    return 50;</span>
  }

  /**
   * Gets the upper boundary for instances per cluster.
   *
   * @return the upper boundary for instances per cluster
   */
  public int getMaxInstNum() { 
<span class="fc" id="L875">    return m_MaxInstNum; </span>
  }
  
  /**
   * Sets the upper boundary for instances per cluster.
   *
   * @param newMaxInstNum new upper boundary for instances per cluster
   */
  public void setMaxInstNum(int newMaxInstNum) {
<span class="fc" id="L884">    m_MaxInstNum = newMaxInstNum;</span>
<span class="fc" id="L885">  }</span>
  
  /**
   * Returns the tip text for this property
   * 
   * @return tip text for this property suitable for
   *         displaying in the explorer/experimenter gui
   */
  public String maxInstNumTipText() {
<span class="nc" id="L894">    return &quot;The upper boundary for instances per cluster.&quot;;</span>
  }

  /**
   * Sets the upper and lower boundary for the radius of the clusters.
   *
   * @param fromTo the string containing the upper and lower boundary for
   * the radius  of the clusters, separated by ..
   */
  protected void setRadiuses(String fromTo) {
<span class="fc" id="L904">    int i = fromTo.indexOf(&quot;..&quot;);</span>
<span class="fc" id="L905">    String from = fromTo.substring(0, i);</span>
<span class="fc" id="L906">    setMinRadius(Double.valueOf(from).doubleValue());</span>
<span class="fc" id="L907">    String to = fromTo.substring(i + 2, fromTo.length());</span>
<span class="fc" id="L908">    setMaxRadius(Double.valueOf(to).doubleValue());</span>
<span class="fc" id="L909">  }</span>

  /**
   * Gets the upper and lower boundary for the radius of the clusters.
   *
   * @return the string containing the upper and lower boundary for
   * the radius  of the clusters, separated by ..
   */
  protected String getRadiuses() {
<span class="fc" id="L918">    String fromTo = &quot;&quot; </span>
<span class="fc" id="L919">                    + Utils.doubleToString(getMinRadius(), 2) + &quot;..&quot;</span>
<span class="fc" id="L920">                    + Utils.doubleToString(getMaxRadius(), 2);</span>
<span class="fc" id="L921">    return fromTo;</span>
  }
  
  /**
   * Returns the tip text for this property
   * 
   * @return tip text for this property suitable for
   *         displaying in the explorer/experimenter gui
   */
  protected String radiusesTipText() {
<span class="nc" id="L931">    return &quot;The upper and lower boundary for the radius of the clusters.&quot;;</span>
  }

  /**
   * returns the default min radius
   * 
   * @return the default min radius
   */
  protected double defaultMinRadius() {
<span class="fc" id="L940">    return 0.1;</span>
  }

  /**
   * Gets the lower boundary for the radiuses of the clusters.
   *
   * @return the lower boundary for the radiuses of the clusters
   */
  public double getMinRadius() { 
<span class="fc" id="L949">    return m_MinRadius; </span>
  }
  
  /**
   * Sets the lower boundary for the radiuses of the clusters.
   *
   * @param newMinRadius new lower boundary for the radiuses of the clusters
   */
  public void setMinRadius(double newMinRadius) {
<span class="fc" id="L958">    m_MinRadius = newMinRadius;</span>
<span class="fc" id="L959">  }</span>
  
  /**
   * Returns the tip text for this property
   * 
   * @return tip text for this property suitable for
   *         displaying in the explorer/experimenter gui
   */
  public String minRadiusTipText() {
<span class="nc" id="L968">    return &quot;The lower boundary for the radius of the clusters.&quot;;</span>
  }

  /**
   * returns the default max radius
   * 
   * @return the default max radius
   */
  protected double defaultMaxRadius() {
<span class="fc" id="L977">    return Math.sqrt(2.0);</span>
  }

  /**
   * Gets the upper boundary for the radiuses of the clusters.
   *
   * @return the upper boundary for the radiuses of the clusters
   */
  public double getMaxRadius() { 
<span class="fc" id="L986">    return m_MaxRadius; </span>
  }
  
  /**
   * Sets the upper boundary for the radiuses of the clusters.
   *
   * @param newMaxRadius new upper boundary for the radiuses of the clusters
   */
  public void setMaxRadius(double newMaxRadius) {
<span class="fc" id="L995">    m_MaxRadius = newMaxRadius;</span>
<span class="fc" id="L996">  }</span>
  
  /**
   * Returns the tip text for this property
   * 
   * @return tip text for this property suitable for
   *         displaying in the explorer/experimenter gui
   */
  public String maxRadiusTipText() {
<span class="nc" id="L1005">    return &quot;The upper boundary for the radius of the clusters.&quot;;</span>
  }

  /**
   * returns the default pattern
   * 
   * @return the default pattern
   */
  protected SelectedTag defaultPattern() {
<span class="fc" id="L1014">    return new SelectedTag(RANDOM, TAGS_PATTERN);</span>
  }
  
  /**
   * Gets the pattern type.
   *
   * @return the current pattern type
   */
  public SelectedTag getPattern() { 
<span class="nc" id="L1023">    return new SelectedTag(m_Pattern, TAGS_PATTERN);</span>
  }

  /**
   * Sets the pattern type.
   *
   * @param value new pattern type 
   */
  public void setPattern(SelectedTag value) {
<span class="pc bpc" id="L1032" title="1 of 2 branches missed.">    if (value.getTags() == TAGS_PATTERN)</span>
<span class="fc" id="L1033">      m_Pattern = value.getSelectedTag().getID();</span>
<span class="fc" id="L1034">  }</span>
  
  /**
   * Returns the tip text for this property
   * 
   * @return tip text for this property suitable for
   *         displaying in the explorer/experimenter gui
   */
  public String patternTipText() {
<span class="nc" id="L1043">    return &quot;The pattern for generating the data.&quot;;</span>
  }

  /**
   * returns the default distance multiplier
   * 
   * @return the default distance multiplier
   */
  protected double defaultDistMult() {
<span class="fc" id="L1052">    return 4.0;</span>
  }

  /**
   * Gets the distance multiplier.
   *
   * @return the distance multiplier
   */
  public double getDistMult() { 
<span class="nc" id="L1061">    return m_DistMult; </span>
  }
  
  /**
   * Sets the distance multiplier.
   *
   * @param newDistMult new distance multiplier
   */
  public void setDistMult(double newDistMult) {
<span class="fc" id="L1070">    m_DistMult = newDistMult;</span>
<span class="fc" id="L1071">  }</span>
  
  /**
   * Returns the tip text for this property
   * 
   * @return tip text for this property suitable for
   *         displaying in the explorer/experimenter gui
   */
  public String distMultTipText() {
<span class="nc" id="L1080">    return &quot;The distance multiplier (in combination with the 'Grid' pattern).&quot;;</span>
  }

  /**
   * returns the default number of cycles
   * 
   * @return the default number of cycles
   */
  protected int defaultNumCycles() {
<span class="fc" id="L1089">    return 4;</span>
  }

  /**
   * Gets the number of cycles.
   *
   * @return the number of cycles
   */
  public int getNumCycles() { 
<span class="nc" id="L1098">    return m_NumCycles; </span>
  }
  
  /**
   * Sets the the number of cycles.
   *
   * @param newNumCycles new number of cycles 
   */
  public void setNumCycles(int newNumCycles) {
<span class="fc" id="L1107">    m_NumCycles = newNumCycles;</span>
<span class="fc" id="L1108">  }</span>
  
  /**
   * Returns the tip text for this property
   * 
   * @return tip text for this property suitable for
   *         displaying in the explorer/experimenter gui
   */
  public String numCyclesTipText() {
<span class="nc" id="L1117">    return &quot;The number of cycles to use (in combination with the 'Sine' pattern).&quot;;</span>
  }

  /**
   * returns the default input order
   * 
   * @return the default input order
   */
  protected SelectedTag defaultInputOrder() {
<span class="fc" id="L1126">    return new SelectedTag(ORDERED, TAGS_INPUTORDER);  // TODO: the only one that is currently implemented, normally RANDOMIZED</span>
  }

  /**
   * Gets the input order.
   *
   * @return the current input order
   */
  public SelectedTag getInputOrder() { 
<span class="nc" id="L1135">    return new SelectedTag(m_InputOrder, TAGS_INPUTORDER);</span>
  }

  /**
   * Sets the input order.
   *
   * @param value new input order 
   */
  public void setInputOrder(SelectedTag value) {
<span class="pc bpc" id="L1144" title="1 of 2 branches missed.">    if (value.getTags() == TAGS_INPUTORDER)</span>
<span class="fc" id="L1145">      m_InputOrder = value.getSelectedTag().getID();</span>
<span class="fc" id="L1146">  }</span>
  
  /**
   * Returns the tip text for this property
   * 
   * @return tip text for this property suitable for
   *         displaying in the explorer/experimenter gui
   */
  public String inputOrderTipText() {
<span class="nc" id="L1155">    return &quot;The input order to use.&quot;;</span>
  }

  /**
   * Gets the ordered flag (option O).
   *
   * @return true if ordered flag is set
   */
  public boolean getOrderedFlag() { 
<span class="pc bpc" id="L1164" title="1 of 2 branches missed.">    return m_InputOrder == ORDERED; </span>
  }

  /**
   * returns the default noise rate
   * 
   * @return the default noise rate
   */
  protected double defaultNoiseRate() {
<span class="fc" id="L1173">    return 0.0;</span>
  }

  /**
   * Gets the percentage of noise set.
   *
   * @return the percentage of noise set
   */
  public double getNoiseRate() { 
<span class="fc" id="L1182">    return m_NoiseRate; </span>
  }
  
  /**
   * Sets the percentage of noise set.
   *
   * @param newNoiseRate new percentage of noise 
   */
  public void setNoiseRate(double newNoiseRate) {
<span class="fc" id="L1191">    m_NoiseRate = newNoiseRate;</span>
<span class="fc" id="L1192">  }</span>
  
  /**
   * Returns the tip text for this property
   * 
   * @return tip text for this property suitable for
   *         displaying in the explorer/experimenter gui
   */
  public String noiseRateTipText() {
<span class="nc" id="L1201">    return &quot;The noise rate to use.&quot;;</span>
  }

  /**
   * Gets the single mode flag.
   *
   * @return true if methode generateExample can be used.
   */
  public boolean getSingleModeFlag() { 
<span class="fc" id="L1210">    return false; </span>
  }
 
  /**
   * Initializes the format for the dataset produced. 
   *
   * @return the output data format
   * @throws Exception data format could not be defined 
   */

  public Instances defineDataFormat() throws Exception {
<span class="fc" id="L1221">    Random random = new Random (getSeed());</span>
<span class="fc" id="L1222">    setRandom(random);</span>
    Instances dataset;
<span class="fc" id="L1224">    FastVector attributes = new FastVector(3);</span>
    Attribute attribute;
<span class="fc" id="L1226">    boolean classFlag = getClassFlag();</span>
    
<span class="fc" id="L1228">    FastVector classValues = null;</span>
<span class="pc bpc" id="L1229" title="1 of 2 branches missed.">    if (classFlag) classValues = new FastVector (m_NumClusters);     </span>

    // define dataset
<span class="fc bfc" id="L1232" title="All 2 branches covered.">    for (int i = 0; i &lt; getNumAttributes(); i++) {</span>
<span class="fc" id="L1233">      attribute = new Attribute(&quot;X&quot; + i); </span>
<span class="fc" id="L1234">      attributes.addElement(attribute);</span>
    }
    
<span class="pc bpc" id="L1237" title="1 of 2 branches missed.">    if (classFlag) {</span>
<span class="nc bnc" id="L1238" title="All 2 branches missed.">      for (int i = 0; i &lt; m_NumClusters; i++)</span>
<span class="nc" id="L1239">	classValues.addElement(&quot;c&quot; + i);</span>
<span class="nc" id="L1240">      attribute = new Attribute (&quot;class&quot;, classValues); </span>
<span class="nc" id="L1241">      attributes.addElement(attribute);</span>
    }

<span class="fc" id="L1244">    dataset = new Instances(getRelationNameToUse(), attributes, 0);</span>
<span class="pc bpc" id="L1245" title="1 of 2 branches missed.">    if (classFlag) </span>
<span class="nc" id="L1246">      dataset.setClassIndex(getNumAttributes());</span>

    // set dataset format of this class
<span class="fc" id="L1249">    Instances format = new Instances(dataset, 0);</span>
<span class="fc" id="L1250">    setDatasetFormat(format);</span>

<span class="fc" id="L1252">    m_ClusterList = defineClusters(random);</span>

    //System.out.println(&quot;dataset&quot; + dataset.numAttributes());
<span class="fc" id="L1255">    return dataset; </span>
  }

  /**
   * Generate an example of the dataset. 
   * @return the instance generated
   * @throws Exception if format not defined or generating &lt;br/&gt;
   * examples one by one is not possible, because voting is chosen
   */

  public Instance generateExample() throws Exception {
<span class="nc" id="L1266">    throw new Exception(&quot;Examples cannot be generated&quot; +</span>
                                           &quot; one by one.&quot;);
  }

  /**
   * Generate all examples of the dataset. 
   * @return the instance generated
   * @throws Exception if format not defined 
   */

  public Instances generateExamples() throws Exception {
<span class="fc" id="L1277">    Random random = getRandom();</span>
<span class="fc" id="L1278">    Instances data = getDatasetFormat();</span>
<span class="pc bpc" id="L1279" title="1 of 2 branches missed.">    if (data == null) throw new Exception(&quot;Dataset format not defined.&quot;);</span>

    // generate examples
<span class="pc bpc" id="L1282" title="1 of 2 branches missed.">    if (getOrderedFlag())</span>
<span class="fc" id="L1283">      data = generateExamples(random, data);</span>
    else
<span class="nc" id="L1285">      throw new Exception(&quot;RANDOMIZED is not yet implemented.&quot;);</span>
  
<span class="fc" id="L1287">    return (data);</span>
  }

  /**
   * Generate all examples of the dataset. 
   * 
   * @param random the random number generator to use
   * @param format the dataset format
   * @return the instance generated
   * @throws Exception if format not defined
   */
  public Instances generateExamples(Random random,
				    Instances format) throws Exception {
<span class="fc" id="L1300">    Instance example = null;</span>
    
<span class="pc bpc" id="L1302" title="1 of 2 branches missed.">    if (format == null) </span>
<span class="nc" id="L1303">      throw new Exception(&quot;Dataset format not defined.&quot;);</span>

    // generate examples for one cluster after another
<span class="fc" id="L1306">    int cNum = 0;</span>
<span class="fc" id="L1307">    for (Enumeration enm = m_ClusterList.elements();</span>
<span class="fc bfc" id="L1308" title="All 2 branches covered.">	 enm.hasMoreElements(); cNum++) {</span>
<span class="fc" id="L1309">      Cluster cl  = (Cluster) enm.nextElement();</span>
<span class="fc" id="L1310">      double stdDev = cl.getStdDev();</span>
<span class="fc" id="L1311">      int instNum = cl.getInstNum();</span>
<span class="fc" id="L1312">      double[] center = cl.getCenter();</span>
<span class="fc" id="L1313">      String cName = &quot;c&quot; + cNum;</span>

<span class="fc bfc" id="L1315" title="All 2 branches covered.">      for (int i = 0; i &lt; instNum; i++) {</span>
	// generate example
<span class="fc" id="L1317">	example = generateInstance(</span>
                    format, random, stdDev, center, cName);
       
<span class="pc bpc" id="L1320" title="1 of 2 branches missed.">	if (example != null)</span>
<span class="fc" id="L1321">	  example.setDataset(format);</span>
<span class="fc" id="L1322">	format.add(example);</span>
      }
    }

<span class="fc" id="L1326">    return (format);</span>
  }

  /**
   * Generate an example of the dataset. 
   * 
   * @param format the dataset format
   * @param randomG the random number generator
   * @param stdDev the standard deviation to use
   * @param center the centers
   * @param cName the class value
   * @return the instance generated
   * examples one by one is not possible, because voting is chosen
   */
  private Instance generateInstance (Instances format,
				     Random randomG,
				     double stdDev,
				     double[] center,
				     String cName) {
    Instance example;
<span class="fc" id="L1346">    int numAtts = getNumAttributes();</span>
<span class="pc bpc" id="L1347" title="1 of 2 branches missed.">    if (getClassFlag()) </span>
<span class="nc" id="L1348">      numAtts++;</span>

<span class="fc" id="L1350">    example = new Instance(numAtts);</span>
<span class="fc" id="L1351">    example.setDataset(format);</span>
        
<span class="fc bfc" id="L1353" title="All 2 branches covered.">    for (int i = 0; i &lt; getNumAttributes(); i++)</span>
<span class="fc" id="L1354">      example.setValue(i, randomG.nextGaussian() * stdDev + center[i]); </span>
    
<span class="pc bpc" id="L1356" title="1 of 2 branches missed.">    if (getClassFlag())</span>
<span class="nc" id="L1357">      example.setClassValue(cName);</span>

<span class="fc" id="L1359">    return example; </span>
  }

 /**
   * Defines the clusters 
   *
   * @param random random number generator
   * @return the cluster definitions
   * @throws Exception if defining fails
   */
  private FastVector defineClusters(Random random)
   throws Exception {

<span class="pc bpc" id="L1372" title="1 of 2 branches missed.">    if (m_Pattern == GRID)</span>
<span class="nc" id="L1373">      return defineClustersGRID(random);</span>
    else
<span class="fc" id="L1375">      return defineClustersRANDOM(random);</span>
  }

  /**
   * Defines the clusters if pattern is GRID
   *
   * @param random random number generator
   * @return the defined clusters for GRID
   * @throws Exception if something goes wrong
   */
  private FastVector defineClustersGRID(Random random)
    throws Exception {

<span class="nc" id="L1388">    FastVector clusters = new FastVector(m_NumClusters);</span>
<span class="nc" id="L1389">    double diffInstNum = (double) (m_MaxInstNum - m_MinInstNum);</span>
<span class="nc" id="L1390">    double minInstNum = (double) m_MinInstNum;</span>
<span class="nc" id="L1391">    double diffRadius = m_MaxRadius - m_MinRadius;</span>
    Cluster cluster;

    // compute gridsize
<span class="nc" id="L1395">    double gs = Math.pow(m_NumClusters, 1.0 / getNumAttributes());</span>
    
<span class="nc bnc" id="L1397" title="All 2 branches missed.">    if (gs - ((double) ((int) gs))  &gt; 0.0) {</span>
<span class="nc" id="L1398">      m_GridSize = (int) (gs + 1.0);</span>
<span class="nc" id="L1399">    } else { m_GridSize = (int) gs; }</span>

    // compute gridwidth
<span class="nc" id="L1402">    m_GridWidth = ((m_MaxRadius + m_MinRadius) / 2) * m_DistMult;</span>

    //System.out.println(&quot;GridSize= &quot; + m_GridSize);
    //System.out.println(&quot;GridWidth= &quot; + m_GridWidth);
    
    // initialize gridvector with zeros
<span class="nc" id="L1408">    GridVector gv = new GridVector(getNumAttributes(), m_GridSize);</span>

<span class="nc bnc" id="L1410" title="All 2 branches missed.">    for (int i = 0; i &lt; m_NumClusters; i++) {</span>
<span class="nc" id="L1411">      int instNum = (int) (random.nextDouble() * diffInstNum</span>
                                   + minInstNum);
<span class="nc" id="L1413">      double radius = (random.nextDouble() * diffRadius) + m_MinRadius;</span>

      // center is defined in the constructor of cluster
<span class="nc" id="L1416">      cluster = new Cluster(instNum, radius,</span>
<span class="nc" id="L1417">			    gv.getGridVector(), m_GridWidth);</span>
<span class="nc" id="L1418">      clusters.addElement((Object) cluster);</span>
<span class="nc" id="L1419">      gv.addOne();</span>
    }
<span class="nc" id="L1421">    return clusters;</span>
  }

 /**
   * Defines the clusters if pattern is RANDOM
   *
   * @param random random number generator
   * @return the cluster definitions
   * @throws Exception if something goes wrong
   */
  private FastVector defineClustersRANDOM(Random random)
    throws Exception {

<span class="fc" id="L1434">    FastVector clusters = new FastVector(m_NumClusters);</span>
<span class="fc" id="L1435">    double diffInstNum = (double) (m_MaxInstNum - m_MinInstNum);</span>
<span class="fc" id="L1436">    double minInstNum = (double) m_MinInstNum;</span>
<span class="fc" id="L1437">    double diffRadius = m_MaxRadius - m_MinRadius;</span>
    Cluster cluster;

<span class="fc bfc" id="L1440" title="All 2 branches covered.">    for (int i = 0; i &lt; m_NumClusters; i++) {</span>
<span class="fc" id="L1441">      int instNum = (int) (random.nextDouble() * diffInstNum</span>
                                   + minInstNum);
<span class="fc" id="L1443">      double radius = (random.nextDouble() * diffRadius) + m_MinRadius;</span>

      // center is defined in the constructor of cluster
<span class="fc" id="L1446">      cluster = new Cluster(instNum, radius, random);</span>
<span class="fc" id="L1447">      clusters.addElement((Object) cluster);</span>
    }
<span class="fc" id="L1449">    return clusters;</span>
  }


  /**
   * Compiles documentation about the data generation after
   * the generation process
   *
   * @return string with additional information about generated dataset
   * @throws Exception no input structure has been defined
   */
  public String generateFinished() throws Exception {
<span class="fc" id="L1461">    return &quot;&quot;;</span>
  }
  
  /**
   * Compiles documentation about the data generation before
   * the generation process
   *
   * @return string with additional information 
   */
  public String generateStart() {
<span class="fc" id="L1471">    StringBuffer docu = new StringBuffer();</span>

<span class="fc" id="L1473">    int sumInst = 0;</span>
<span class="fc" id="L1474">    int cNum = 0;</span>
<span class="fc" id="L1475">    for (Enumeration enm = m_ClusterList.elements();</span>
<span class="fc bfc" id="L1476" title="All 2 branches covered.">	 enm.hasMoreElements(); cNum++) {</span>
<span class="fc" id="L1477">      Cluster cl  = (Cluster) enm.nextElement();</span>
<span class="fc" id="L1478">      docu.append(&quot;%\n&quot;);</span>
<span class="fc" id="L1479">      docu.append(&quot;% Cluster: c&quot;+ cNum + &quot;\n&quot;);</span>
<span class="fc" id="L1480">      docu.append(&quot;% ----------------------------------------------\n&quot;);</span>
<span class="fc" id="L1481">      docu.append(&quot;% StandardDeviation: &quot;</span>
<span class="fc" id="L1482">		  + Utils.doubleToString(cl.getStdDev(), 2) + &quot;\n&quot;);</span>
<span class="fc" id="L1483">      docu.append(&quot;% Number of instances: &quot;</span>
<span class="fc" id="L1484">		  + cl.getInstNum() + &quot;\n&quot;);</span>
<span class="fc" id="L1485">      sumInst += cl.getInstNum();</span>
<span class="fc" id="L1486">      double[] center = cl.getCenter();</span>
<span class="fc" id="L1487">      docu.append(&quot;% &quot;); </span>
<span class="fc bfc" id="L1488" title="All 2 branches covered.">      for (int i = 0; i &lt; center.length - 1; i++) {</span>
<span class="fc" id="L1489">        docu.append(Utils.doubleToString(center[i], 2) + &quot;, &quot;);</span>
      }
<span class="fc" id="L1491">      docu.append(Utils.doubleToString(center[center.length - 1], 2) + &quot;\n&quot;);</span>
    }
<span class="fc" id="L1493">    docu.append(&quot;%\n% ----------------------------------------------\n&quot;); </span>
<span class="fc" id="L1494">    docu.append(&quot;% Total number of instances: &quot; + sumInst + &quot;\n&quot;);</span>
<span class="fc" id="L1495">    docu.append(&quot;%                            in &quot; + cNum + &quot; clusters\n&quot;);</span>
<span class="fc" id="L1496">    docu.append(&quot;% Pattern chosen           : &quot;);</span>
<span class="pc bpc" id="L1497" title="1 of 2 branches missed.">    if (m_Pattern == GRID) </span>
<span class="nc" id="L1498">      docu.append(</span>
          &quot;GRID, &quot; + &quot;distance multiplier = &quot; 
<span class="nc" id="L1500">          + Utils.doubleToString(m_DistMult, 2) + &quot;\n&quot;);</span>
<span class="pc bpc" id="L1501" title="1 of 2 branches missed.">    else if (m_Pattern == SINE) </span>
<span class="nc" id="L1502">      docu.append(&quot;SINE\n&quot;);</span>
    else
<span class="fc" id="L1504">      docu.append(&quot;RANDOM\n&quot;);</span>

<span class="fc" id="L1506">    return docu.toString();</span>
  }
  
  /**
   * Returns the revision string.
   * 
   * @return		the revision
   */
  public String getRevision() {
<span class="nc" id="L1515">    return RevisionUtils.extract(&quot;$Revision: 1.8 $&quot;);</span>
  }

  /**
   * Main method for testing this class.
   *
   * @param args should contain arguments for the data producer: 
   */
  public static void main(String[] args) {
<span class="nc" id="L1524">    runDataGenerator(new BIRCHCluster(), args);</span>
<span class="nc" id="L1525">  }</span>
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>
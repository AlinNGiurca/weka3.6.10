<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>GeneticSearch.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCoverage analysis of project &quot;Weka-3.6.10&quot; (powered by JaCoCo from EclEmma)</a> &gt; <a href="index.source.html" class="el_package">weka.attributeSelection</a> &gt; <span class="el_source">GeneticSearch.java</span></div><h1>GeneticSearch.java</h1><pre class="source lang-java linenums">/*
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation; either version 2 of the License, or
 *    (at your option) any later version.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not, write to the Free Software
 *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/*
 *    GeneticSearch.java
 *    Copyright (C) 1999 University of Waikato, Hamilton, New Zealand
 *
 */

package  weka.attributeSelection;

import weka.core.Instances;
import weka.core.Option;
import weka.core.OptionHandler;
import weka.core.Range;
import weka.core.RevisionHandler;
import weka.core.RevisionUtils;
import weka.core.TechnicalInformation;
import weka.core.TechnicalInformationHandler;
import weka.core.Utils;
import weka.core.TechnicalInformation.Field;
import weka.core.TechnicalInformation.Type;

import java.io.Serializable;
import java.util.BitSet;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Random;
import java.util.Vector;

/** 
 &lt;!-- globalinfo-start --&gt;
 * GeneticSearch:&lt;br/&gt;
 * &lt;br/&gt;
 * Performs a search using the simple genetic algorithm described in Goldberg (1989).&lt;br/&gt;
 * &lt;br/&gt;
 * For more information see:&lt;br/&gt;
 * &lt;br/&gt;
 * David E. Goldberg (1989). Genetic algorithms in search, optimization and machine learning. Addison-Wesley.
 * &lt;p/&gt;
 &lt;!-- globalinfo-end --&gt;
 *
 &lt;!-- technical-bibtex-start --&gt;
 * BibTeX:
 * &lt;pre&gt;
 * &amp;#64;book{Goldberg1989,
 *    author = {David E. Goldberg},
 *    publisher = {Addison-Wesley},
 *    title = {Genetic algorithms in search, optimization and machine learning},
 *    year = {1989},
 *    ISBN = {0201157675}
 * }
 * &lt;/pre&gt;
 * &lt;p/&gt;
 &lt;!-- technical-bibtex-end --&gt;
 *
 &lt;!-- options-start --&gt;
 * Valid options are: &lt;p/&gt;
 * 
 * &lt;pre&gt; -P &amp;lt;start set&amp;gt;
 *  Specify a starting set of attributes.
 *  Eg. 1,3,5-7.If supplied, the starting set becomes
 *  one member of the initial random
 *  population.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -Z &amp;lt;population size&amp;gt;
 *  Set the size of the population (even number).
 *  (default = 20).&lt;/pre&gt;
 * 
 * &lt;pre&gt; -G &amp;lt;number of generations&amp;gt;
 *  Set the number of generations.
 *  (default = 20)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -C &amp;lt;probability of crossover&amp;gt;
 *  Set the probability of crossover.
 *  (default = 0.6)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -M &amp;lt;probability of mutation&amp;gt;
 *  Set the probability of mutation.
 *  (default = 0.033)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -R &amp;lt;report frequency&amp;gt;
 *  Set frequency of generation reports.
 *  e.g, setting the value to 5 will 
 *  report every 5th generation
 *  (default = number of generations)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -S &amp;lt;seed&amp;gt;
 *  Set the random number seed.
 *  (default = 1)&lt;/pre&gt;
 * 
 &lt;!-- options-end --&gt;
 *
 * @author Mark Hall (mhall@cs.waikato.ac.nz)
 * @version $Revision: 6759 $
 */
public class GeneticSearch 
  extends ASSearch 
  implements StartSetHandler, OptionHandler, TechnicalInformationHandler {

  /** for serialization */
  static final long serialVersionUID = -1618264232838472679L;
  
  /** 
   * holds a starting set as an array of attributes. Becomes one member of the
   * initial random population
   */
  private int[] m_starting;

  /** holds the start set for the search as a Range */
  private Range m_startRange;
  
 /** does the data have a class */
  private boolean m_hasClass;
 
  /** holds the class index */
  private int m_classIndex;
 
  /** number of attributes in the data */
  private int m_numAttribs;

  /** the current population */
  private GABitSet [] m_population;

  /** the number of individual solutions */
  private int m_popSize;

  /** the best population member found during the search */
  private GABitSet m_best;

  /** the number of features in the best population member */
  private int m_bestFeatureCount;

  /** the number of entries to cache for lookup */
  private int m_lookupTableSize;

  /** the lookup table */
  private Hashtable m_lookupTable;

  /** random number generation */
  private Random m_random;

  /** seed for random number generation */
  private int m_seed;

  /** the probability of crossover occuring */
  private double m_pCrossover;

  /** the probability of mutation occuring */
  private double m_pMutation;

  /** sum of the current population fitness */
  private double m_sumFitness;

  private double m_maxFitness;
  private double m_minFitness;
  private double m_avgFitness;

  /** the maximum number of generations to evaluate */
  private int m_maxGenerations;

  /** how often reports are generated */
  private int m_reportFrequency;

  /** holds the generation reports */
  private StringBuffer m_generationReports;

  // Inner class
  /**
   * A bitset for the genetic algorithm
   */
  protected class GABitSet 
    implements Cloneable, Serializable, RevisionHandler {
    
    /** for serialization */
    static final long serialVersionUID = -2930607837482622224L;
    
    /** the bitset */
    private BitSet m_chromosome;

    /** holds raw merit */
<span class="fc" id="L195">    private double m_objective = -Double.MAX_VALUE;</span>
    
    /** the fitness */
    private double m_fitness;
    
    /**
     * Constructor
     */
<span class="fc" id="L203">    public GABitSet () {</span>
<span class="fc" id="L204">      m_chromosome = new BitSet();</span>
<span class="fc" id="L205">    }</span>

    /**
     * makes a copy of this GABitSet
     * @return a copy of the object
     * @throws CloneNotSupportedException if something goes wrong
     */
    public Object clone() throws CloneNotSupportedException {
<span class="fc" id="L213">      GABitSet temp = new GABitSet();</span>
      
<span class="fc" id="L215">      temp.setObjective(this.getObjective());</span>
<span class="fc" id="L216">      temp.setFitness(this.getFitness());</span>
<span class="fc" id="L217">      temp.setChromosome((BitSet)(this.m_chromosome.clone()));</span>
<span class="fc" id="L218">      return temp;</span>
      //return super.clone();
    }

    /**
     * sets the objective merit value
     * @param objective the objective value of this population member
     */
    public void setObjective(double objective) {
<span class="fc" id="L227">      m_objective = objective;</span>
<span class="fc" id="L228">    }</span>
      
    /**
     * gets the objective merit
     * @return the objective merit of this population member
     */
    public double getObjective() {
<span class="fc" id="L235">      return m_objective;</span>
    }

    /**
     * sets the scaled fitness
     * @param fitness the scaled fitness of this population member
     */
    public void setFitness(double fitness) {
<span class="fc" id="L243">      m_fitness = fitness;</span>
<span class="fc" id="L244">    }</span>

    /**
     * gets the scaled fitness
     * @return the scaled fitness of this population member
     */
    public double getFitness() {
<span class="fc" id="L251">      return m_fitness;</span>
    }

    /**
     * get the chromosome
     * @return the chromosome of this population member
     */
    public BitSet getChromosome() {
<span class="fc" id="L259">      return m_chromosome;</span>
    }

    /**
     * set the chromosome
     * @param c the chromosome to be set for this population member
     */
    public void setChromosome(BitSet c) {
<span class="fc" id="L267">      m_chromosome = c;</span>
<span class="fc" id="L268">    }</span>

    /**
     * unset a bit in the chromosome
     * @param bit the bit to be cleared
     */
    public void clear(int bit) {
<span class="fc" id="L275">      m_chromosome.clear(bit);</span>
<span class="fc" id="L276">    }</span>

    /**
     * set a bit in the chromosome
     * @param bit the bit to be set
     */
    public void set(int bit) {
<span class="fc" id="L283">      m_chromosome.set(bit);</span>
<span class="fc" id="L284">    }</span>

    /**
     * get the value of a bit in the chromosome
     * @param bit the bit to query
     * @return the value of the bit
     */
    public boolean get(int bit) {
<span class="fc" id="L292">      return m_chromosome.get(bit);</span>
    }
    
    /**
     * Returns the revision string.
     * 
     * @return		the revision
     */
    public String getRevision() {
<span class="nc" id="L301">      return RevisionUtils.extract(&quot;$Revision: 6759 $&quot;);</span>
    }
  }

  /**
   * Returns an enumeration describing the available options.
   * @return an enumeration of all the available options.
   **/
  public Enumeration listOptions () {
<span class="fc" id="L310">    Vector newVector = new Vector(6);</span>

<span class="fc" id="L312">    newVector.addElement(new Option(&quot;\tSpecify a starting set of attributes.&quot; </span>
                                    + &quot;\n\tEg. 1,3,5-7.&quot;
                                    +&quot;If supplied, the starting set becomes&quot;
                                    +&quot;\n\tone member of the initial random&quot;
                                    +&quot;\n\tpopulation.&quot;
                                    ,&quot;P&quot;,1
                                    , &quot;-P &lt;start set&gt;&quot;));
<span class="fc" id="L319">    newVector.addElement(new Option(&quot;\tSet the size of the population (even number).&quot;</span>
                                    +&quot;\n\t(default = 20).&quot;
                                    , &quot;Z&quot;, 1
                                    , &quot;-Z &lt;population size&gt;&quot;));
<span class="fc" id="L323">    newVector.addElement(new Option(&quot;\tSet the number of generations.&quot;</span>
                                    +&quot;\n\t(default = 20)&quot; 
                                    , &quot;G&quot;, 1, &quot;-G &lt;number of generations&gt;&quot;));
<span class="fc" id="L326">    newVector.addElement(new Option(&quot;\tSet the probability of crossover.&quot;</span>
                                    +&quot;\n\t(default = 0.6)&quot; 
                                    , &quot;C&quot;, 1, &quot;-C &lt;probability of&quot;
                                    +&quot; crossover&gt;&quot;));    
<span class="fc" id="L330">    newVector.addElement(new Option(&quot;\tSet the probability of mutation.&quot;</span>
                                    +&quot;\n\t(default = 0.033)&quot; 
                                    , &quot;M&quot;, 1, &quot;-M &lt;probability of mutation&gt;&quot;));

<span class="fc" id="L334">    newVector.addElement(new Option(&quot;\tSet frequency of generation reports.&quot;</span>
                                    +&quot;\n\te.g, setting the value to 5 will &quot;
                                    +&quot;\n\treport every 5th generation&quot;
                                    +&quot;\n\t(default = number of generations)&quot; 
                                    , &quot;R&quot;, 1, &quot;-R &lt;report frequency&gt;&quot;));
<span class="fc" id="L339">    newVector.addElement(new Option(&quot;\tSet the random number seed.&quot;</span>
                                    +&quot;\n\t(default = 1)&quot; 
                                    , &quot;S&quot;, 1, &quot;-S &lt;seed&gt;&quot;));
<span class="fc" id="L342">    return  newVector.elements();</span>
  }

  /**
   * Parses a given list of options. &lt;p/&gt;
   *
   &lt;!-- options-start --&gt;
   * Valid options are: &lt;p/&gt;
   * 
   * &lt;pre&gt; -P &amp;lt;start set&amp;gt;
   *  Specify a starting set of attributes.
   *  Eg. 1,3,5-7.If supplied, the starting set becomes
   *  one member of the initial random
   *  population.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -Z &amp;lt;population size&amp;gt;
   *  Set the size of the population (even number).
   *  (default = 20).&lt;/pre&gt;
   * 
   * &lt;pre&gt; -G &amp;lt;number of generations&amp;gt;
   *  Set the number of generations.
   *  (default = 20)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -C &amp;lt;probability of crossover&amp;gt;
   *  Set the probability of crossover.
   *  (default = 0.6)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -M &amp;lt;probability of mutation&amp;gt;
   *  Set the probability of mutation.
   *  (default = 0.033)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -R &amp;lt;report frequency&amp;gt;
   *  Set frequency of generation reports.
   *  e.g, setting the value to 5 will 
   *  report every 5th generation
   *  (default = number of generations)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -S &amp;lt;seed&amp;gt;
   *  Set the random number seed.
   *  (default = 1)&lt;/pre&gt;
   * 
   &lt;!-- options-end --&gt;
   *
   * @param options the list of options as an array of strings
   * @throws Exception if an option is not supported
   *
   **/
  public void setOptions (String[] options)
    throws Exception {
    String optionString;
<span class="fc" id="L392">    resetOptions();</span>

<span class="fc" id="L394">    optionString = Utils.getOption('P', options);</span>
<span class="pc bpc" id="L395" title="1 of 2 branches missed.">    if (optionString.length() != 0) {</span>
<span class="nc" id="L396">      setStartSet(optionString);</span>
    }

<span class="fc" id="L399">    optionString = Utils.getOption('Z', options);</span>
<span class="fc bfc" id="L400" title="All 2 branches covered.">    if (optionString.length() != 0) {</span>
<span class="fc" id="L401">      setPopulationSize(Integer.parseInt(optionString));</span>
    }

<span class="fc" id="L404">    optionString = Utils.getOption('G', options);</span>
<span class="fc bfc" id="L405" title="All 2 branches covered.">    if (optionString.length() != 0) {</span>
<span class="fc" id="L406">      setMaxGenerations(Integer.parseInt(optionString));</span>
<span class="fc" id="L407">      setReportFrequency(Integer.parseInt(optionString));</span>
    }

<span class="fc" id="L410">    optionString = Utils.getOption('C', options);</span>
<span class="fc bfc" id="L411" title="All 2 branches covered.">    if (optionString.length() != 0) {</span>
<span class="fc" id="L412">      setCrossoverProb((new Double(optionString)).doubleValue());</span>
    }

<span class="fc" id="L415">    optionString = Utils.getOption('M', options);</span>
<span class="fc bfc" id="L416" title="All 2 branches covered.">    if (optionString.length() != 0) {</span>
<span class="fc" id="L417">      setMutationProb((new Double(optionString)).doubleValue());</span>
    }

<span class="fc" id="L420">    optionString = Utils.getOption('R', options);</span>
<span class="fc bfc" id="L421" title="All 2 branches covered.">    if (optionString.length() != 0) {</span>
<span class="fc" id="L422">      setReportFrequency(Integer.parseInt(optionString));</span>
    }

<span class="fc" id="L425">    optionString = Utils.getOption('S', options);</span>
<span class="fc bfc" id="L426" title="All 2 branches covered.">    if (optionString.length() != 0) {</span>
<span class="fc" id="L427">      setSeed(Integer.parseInt(optionString));</span>
    }
<span class="fc" id="L429">  }</span>

  /**
   * Gets the current settings of ReliefFAttributeEval.
   *
   * @return an array of strings suitable for passing to setOptions()
   */
  public String[] getOptions () {
<span class="fc" id="L437">    String[] options = new String[14];</span>
<span class="fc" id="L438">    int current = 0;</span>

<span class="pc bpc" id="L440" title="1 of 2 branches missed.">    if (!(getStartSet().equals(&quot;&quot;))) {</span>
<span class="nc" id="L441">      options[current++] = &quot;-P&quot;;</span>
<span class="nc" id="L442">      options[current++] = &quot;&quot;+startSetToString();</span>
    }
<span class="fc" id="L444">    options[current++] = &quot;-Z&quot;;</span>
<span class="fc" id="L445">    options[current++] = &quot;&quot; + getPopulationSize();</span>
<span class="fc" id="L446">    options[current++] = &quot;-G&quot;;</span>
<span class="fc" id="L447">    options[current++] = &quot;&quot; + getMaxGenerations();</span>
<span class="fc" id="L448">    options[current++] = &quot;-C&quot;;</span>
<span class="fc" id="L449">    options[current++] = &quot;&quot; + getCrossoverProb();</span>
<span class="fc" id="L450">    options[current++] = &quot;-M&quot;;</span>
<span class="fc" id="L451">    options[current++] = &quot;&quot; + getMutationProb();</span>
<span class="fc" id="L452">    options[current++] = &quot;-R&quot;;</span>
<span class="fc" id="L453">    options[current++] = &quot;&quot; + getReportFrequency();</span>
<span class="fc" id="L454">    options[current++] = &quot;-S&quot;;</span>
<span class="fc" id="L455">    options[current++] = &quot;&quot; + getSeed();</span>

<span class="fc bfc" id="L457" title="All 2 branches covered.">    while (current &lt; options.length) {</span>
<span class="fc" id="L458">      options[current++] = &quot;&quot;;</span>
    }
<span class="fc" id="L460">    return  options;</span>
  }

  /**
   * Returns the tip text for this property
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String startSetTipText() {
<span class="nc" id="L469">    return &quot;Set a start point for the search. This is specified as a comma &quot;</span>
      +&quot;seperated list off attribute indexes starting at 1. It can include &quot;
      +&quot;ranges. Eg. 1,2,5-9,17. The start set becomes one of the population &quot;
      +&quot;members of the initial population.&quot;;
  }

  /**
   * Sets a starting set of attributes for the search. It is the
   * search method's responsibility to report this start set (if any)
   * in its toString() method.
   * @param startSet a string containing a list of attributes (and or ranges),
   * eg. 1,2,6,10-15.
   * @throws Exception if start set can't be set.
   */
  public void setStartSet (String startSet) throws Exception {
<span class="nc" id="L484">    m_startRange.setRanges(startSet);</span>
<span class="nc" id="L485">  }</span>

  /**
   * Returns a list of attributes (and or attribute ranges) as a String
   * @return a list of attributes (and or attribute ranges)
   */
  public String getStartSet () {
<span class="fc" id="L492">    return m_startRange.getRanges();</span>
  }

  /**
   * Returns the tip text for this property
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String seedTipText() {
<span class="nc" id="L501">    return &quot;Set the random seed.&quot;;</span>
  }

  /**
   * set the seed for random number generation
   * @param s seed value
   */
  public void setSeed(int s) {
<span class="fc" id="L509">    m_seed = s;</span>
<span class="fc" id="L510">  }</span>

  /**
   * get the value of the random number generator's seed
   * @return the seed for random number generation
   */
  public int getSeed() {
<span class="fc" id="L517">    return m_seed;</span>
  }
  
  /**
   * Returns the tip text for this property
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String reportFrequencyTipText() {
<span class="nc" id="L526">    return &quot;Set how frequently reports are generated. Default is equal to &quot;</span>
      +&quot;the number of generations meaning that a report will be printed for &quot;
      +&quot;initial and final generations. Setting the value to 5 will result in &quot;
      +&quot;a report being printed every 5 generations.&quot;;
  }

  /**
   * set how often reports are generated
   * @param f generate reports every f generations
   */
  public void setReportFrequency(int f) {
<span class="fc" id="L537">    m_reportFrequency = f;</span>
<span class="fc" id="L538">  }</span>

  /**
   * get how often repports are generated
   * @return how often reports are generated
   */
  public int getReportFrequency() {
<span class="fc" id="L545">    return m_reportFrequency;</span>
  }

  /**
   * Returns the tip text for this property
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String mutationProbTipText() {
<span class="nc" id="L554">    return &quot;Set the probability of mutation occuring.&quot;;</span>
  }

  /**
   * set the probability of mutation
   * @param m the probability for mutation occuring
   */
  public void setMutationProb(double m) {
<span class="fc" id="L562">    m_pMutation = m;</span>
<span class="fc" id="L563">  }</span>

  /**
   * get the probability of mutation
   * @return the probability of mutation occuring
   */
  public double getMutationProb() {
<span class="fc" id="L570">    return m_pMutation;</span>
  }

  /**
   * Returns the tip text for this property
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String crossoverProbTipText() {
<span class="nc" id="L579">    return &quot;Set the probability of crossover. This is the probability that &quot;</span>
      +&quot;two population members will exchange genetic material.&quot;; 
  }

  /**
   * set the probability of crossover
   * @param c the probability that two population members will exchange
   * genetic material
   */
  public void setCrossoverProb(double c) {
<span class="fc" id="L589">    m_pCrossover = c;</span>
<span class="fc" id="L590">  }</span>

  /**
   * get the probability of crossover
   * @return the probability of crossover
   */
  public double getCrossoverProb() {
<span class="fc" id="L597">    return m_pCrossover;</span>
  }

  /**
   * Returns the tip text for this property
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String maxGenerationsTipText() {
<span class="nc" id="L606">    return &quot;Set the number of generations to evaluate.&quot;;</span>
  }

  /**
   * set the number of generations to evaluate
   * @param m the number of generations
   */
  public void setMaxGenerations(int m) {
<span class="fc" id="L614">    m_maxGenerations = m;</span>
<span class="fc" id="L615">  }</span>

  /**
   * get the number of generations
   * @return the maximum number of generations
   */
  public int getMaxGenerations() {
<span class="fc" id="L622">    return m_maxGenerations;</span>
  }

  /**
   * Returns the tip text for this property
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String populationSizeTipText() {
<span class="nc" id="L631">    return &quot;Set the population size (even number), this is the number of individuals &quot;</span>
      +&quot;(attribute sets) in the population.&quot;;
  }

  /**
   * set the population size
   * @param p the size of the population
   */
  public void setPopulationSize(int p) {
<span class="pc bpc" id="L640" title="1 of 2 branches missed.">    if (p % 2 == 0)</span>
<span class="fc" id="L641">      m_popSize = p;</span>
    else
<span class="nc" id="L643">      System.out.println(&quot;Population size needs to be an even number!&quot;);</span>
<span class="fc" id="L644">  }</span>

  /**
   * get the size of the population
   * @return the population size
   */
  public int getPopulationSize() {
<span class="fc" id="L651">    return m_popSize;</span>
  }

  /**
   * Returns a string describing this search method
   * @return a description of the search suitable for
   * displaying in the explorer/experimenter gui
   */
  public String globalInfo() {
<span class="nc" id="L660">    return </span>
        &quot;GeneticSearch:\n\nPerforms a search using the simple genetic &quot;
      + &quot;algorithm described in Goldberg (1989).\n\n&quot;
      + &quot;For more information see:\n\n&quot;
<span class="nc" id="L664">      + getTechnicalInformation().toString();</span>
  }

  /**
   * Returns an instance of a TechnicalInformation object, containing 
   * detailed information about the technical background of this class,
   * e.g., paper reference or book this class is based on.
   * 
   * @return the technical information about this class
   */
  public TechnicalInformation getTechnicalInformation() {
    TechnicalInformation        result;
    
<span class="nc" id="L677">    result = new TechnicalInformation(Type.BOOK);</span>
<span class="nc" id="L678">    result.setValue(Field.AUTHOR, &quot;David E. Goldberg&quot;);</span>
<span class="nc" id="L679">    result.setValue(Field.YEAR, &quot;1989&quot;);</span>
<span class="nc" id="L680">    result.setValue(Field.TITLE, &quot;Genetic algorithms in search, optimization and machine learning&quot;);</span>
<span class="nc" id="L681">    result.setValue(Field.ISBN, &quot;0201157675&quot;);</span>
<span class="nc" id="L682">    result.setValue(Field.PUBLISHER, &quot;Addison-Wesley&quot;);</span>
    
<span class="nc" id="L684">    return result;</span>
  }

  /**
   * Constructor. Make a new GeneticSearch object
   */
<span class="fc" id="L690">  public GeneticSearch() {</span>
<span class="fc" id="L691">    resetOptions();</span>
<span class="fc" id="L692">  }</span>

  /**
   * converts the array of starting attributes to a string. This is
   * used by getOptions to return the actual attributes specified
   * as the starting set. This is better than using m_startRanges.getRanges()
   * as the same start set can be specified in different ways from the
   * command line---eg 1,2,3 == 1-3. This is to ensure that stuff that
   * is stored in a database is comparable.
   * @return a comma seperated list of individual attribute numbers as a String
   */
  private String startSetToString() {
<span class="nc" id="L704">    StringBuffer FString = new StringBuffer();</span>
    boolean didPrint;
    
<span class="nc bnc" id="L707" title="All 2 branches missed.">    if (m_starting == null) {</span>
<span class="nc" id="L708">      return getStartSet();</span>
    }

<span class="nc bnc" id="L711" title="All 2 branches missed.">    for (int i = 0; i &lt; m_starting.length; i++) {</span>
<span class="nc" id="L712">      didPrint = false;</span>
      
<span class="nc bnc" id="L714" title="All 6 branches missed.">      if ((m_hasClass == false) || </span>
          (m_hasClass == true &amp;&amp; i != m_classIndex)) {
<span class="nc" id="L716">        FString.append((m_starting[i] + 1));</span>
<span class="nc" id="L717">        didPrint = true;</span>
      }
      
<span class="nc bnc" id="L720" title="All 2 branches missed.">      if (i == (m_starting.length - 1)) {</span>
<span class="nc" id="L721">        FString.append(&quot;&quot;);</span>
      }
      else {
<span class="nc bnc" id="L724" title="All 2 branches missed.">        if (didPrint) {</span>
<span class="nc" id="L725">          FString.append(&quot;,&quot;);</span>
          }
      }
    }

<span class="nc" id="L730">    return FString.toString();</span>
  }

  /**
   * returns a description of the search
   * @return a description of the search as a String
   */
  public String toString() {
<span class="fc" id="L738">    StringBuffer GAString = new StringBuffer();</span>
<span class="fc" id="L739">    GAString.append(&quot;\tGenetic search.\n\tStart set: &quot;);</span>

<span class="pc bpc" id="L741" title="1 of 2 branches missed.">    if (m_starting == null) {</span>
<span class="fc" id="L742">      GAString.append(&quot;no attributes\n&quot;);</span>
    }
    else {
<span class="nc" id="L745">      GAString.append(startSetToString()+&quot;\n&quot;);</span>
    }
<span class="fc" id="L747">    GAString.append(&quot;\tPopulation size: &quot;+m_popSize);</span>
<span class="fc" id="L748">    GAString.append(&quot;\n\tNumber of generations: &quot;+m_maxGenerations);</span>
<span class="fc" id="L749">    GAString.append(&quot;\n\tProbability of crossover: &quot;</span>
<span class="fc" id="L750">                +Utils.doubleToString(m_pCrossover,6,3));</span>
<span class="fc" id="L751">    GAString.append(&quot;\n\tProbability of mutation: &quot;</span>
<span class="fc" id="L752">                +Utils.doubleToString(m_pMutation,6,3));</span>
<span class="fc" id="L753">    GAString.append(&quot;\n\tReport frequency: &quot;+m_reportFrequency);</span>
<span class="fc" id="L754">    GAString.append(&quot;\n\tRandom number seed: &quot;+m_seed+&quot;\n&quot;);</span>
<span class="fc" id="L755">    GAString.append(m_generationReports.toString());</span>
<span class="fc" id="L756">    return GAString.toString();</span>
  }

  /**
   * Searches the attribute subset space using a genetic algorithm.
   *
   * @param ASEval the attribute evaluator to guide the search
   * @param data the training instances.
   * @return an array (not necessarily ordered) of selected attribute indexes
   * @throws Exception if the search can't be completed
   */
   public int[] search (ASEvaluation ASEval, Instances data)
    throws Exception {

<span class="fc" id="L770">     m_best = null;</span>
<span class="fc" id="L771">     m_generationReports = new StringBuffer();</span>

<span class="pc bpc" id="L773" title="1 of 2 branches missed.">     if (!(ASEval instanceof SubsetEvaluator)) {</span>
<span class="nc" id="L774">       throw  new Exception(ASEval.getClass().getName() </span>
                            + &quot; is not a &quot; 
                            + &quot;Subset evaluator!&quot;);
     }
     
<span class="pc bpc" id="L779" title="1 of 2 branches missed.">    if (ASEval instanceof UnsupervisedSubsetEvaluator) {</span>
<span class="nc" id="L780">      m_hasClass = false;</span>
    }
    else {
<span class="fc" id="L783">      m_hasClass = true;</span>
<span class="fc" id="L784">      m_classIndex = data.classIndex();</span>
    }

<span class="fc" id="L787">    SubsetEvaluator ASEvaluator = (SubsetEvaluator)ASEval;</span>
<span class="fc" id="L788">    m_numAttribs = data.numAttributes();</span>

<span class="fc" id="L790">    m_startRange.setUpper(m_numAttribs-1);</span>
<span class="pc bpc" id="L791" title="1 of 2 branches missed.">    if (!(getStartSet().equals(&quot;&quot;))) {</span>
<span class="nc" id="L792">      m_starting = m_startRange.getSelection();</span>
    }

    // initial random population
<span class="fc" id="L796">    m_lookupTable = new Hashtable(m_lookupTableSize);</span>
<span class="fc" id="L797">    m_random = new Random(m_seed);</span>
<span class="fc" id="L798">    m_population = new GABitSet [m_popSize];</span>

    // set up random initial population
<span class="fc" id="L801">    initPopulation();</span>
<span class="fc" id="L802">    evaluatePopulation(ASEvaluator);</span>
<span class="fc" id="L803">    populationStatistics();</span>
<span class="fc" id="L804">    scalePopulation();</span>
<span class="fc" id="L805">    checkBest();</span>
<span class="fc" id="L806">    m_generationReports.append(populationReport(0));</span>

    boolean converged;
<span class="fc bfc" id="L809" title="All 2 branches covered.">    for (int i=1;i&lt;=m_maxGenerations;i++) {</span>
<span class="fc" id="L810">      generation();</span>
<span class="fc" id="L811">      evaluatePopulation(ASEvaluator);</span>
<span class="fc" id="L812">      populationStatistics();</span>
<span class="fc" id="L813">      scalePopulation();</span>
      // find the best pop member and check for convergence
<span class="fc" id="L815">      converged = checkBest();</span>

<span class="pc bpc" id="L817" title="1 of 6 branches missed.">      if ((i == m_maxGenerations) || </span>
          ((i % m_reportFrequency) == 0) ||
          (converged == true)) {
<span class="fc" id="L820">        m_generationReports.append(populationReport(i));</span>
<span class="fc bfc" id="L821" title="All 2 branches covered.">        if (converged == true) {</span>
<span class="fc" id="L822">          break;</span>
        }
      }
    }
<span class="fc" id="L826">    return attributeList(m_best.getChromosome());</span>
   }

  /**
   * converts a BitSet into a list of attribute indexes 
   * @param group the BitSet to convert
   * @return an array of attribute indexes
   **/
  private int[] attributeList (BitSet group) {
<span class="fc" id="L835">    int count = 0;</span>

    // count how many were selected
<span class="fc bfc" id="L838" title="All 2 branches covered.">    for (int i = 0; i &lt; m_numAttribs; i++) {</span>
<span class="fc bfc" id="L839" title="All 2 branches covered.">      if (group.get(i)) {</span>
<span class="fc" id="L840">        count++;</span>
      }
    }

<span class="fc" id="L844">    int[] list = new int[count];</span>
<span class="fc" id="L845">    count = 0;</span>

<span class="fc bfc" id="L847" title="All 2 branches covered.">    for (int i = 0; i &lt; m_numAttribs; i++) {</span>
<span class="fc bfc" id="L848" title="All 2 branches covered.">      if (group.get(i)) {</span>
<span class="fc" id="L849">        list[count++] = i;</span>
      }
    }

<span class="fc" id="L853">    return  list;</span>
  }

  /**
   * checks to see if any population members in the current
   * population are better than the best found so far. Also checks
   * to see if the search has converged---that is there is no difference
   * in fitness between the best and worse population member
   * @return true is the search has converged
   * @throws Exception if something goes wrong
   */
  private boolean checkBest() throws Exception {
<span class="fc" id="L865">    int i,count,lowestCount = m_numAttribs;</span>
<span class="fc" id="L866">    double b = -Double.MAX_VALUE;</span>
<span class="fc" id="L867">    GABitSet localbest = null;</span>
    BitSet temp;
<span class="fc" id="L869">    boolean converged = false;</span>
<span class="fc" id="L870">    int oldcount = Integer.MAX_VALUE;</span>

<span class="fc bfc" id="L872" title="All 2 branches covered.">    if (m_maxFitness - m_minFitness &gt; 0) {</span>
      // find the best in this population
<span class="fc bfc" id="L874" title="All 2 branches covered.">      for (i=0;i&lt;m_popSize;i++) {</span>
<span class="fc bfc" id="L875" title="All 2 branches covered.">        if (m_population[i].getObjective() &gt; b) {</span>
<span class="fc" id="L876">          b = m_population[i].getObjective();</span>
<span class="fc" id="L877">          localbest = m_population[i];</span>
<span class="fc" id="L878">          oldcount = countFeatures(localbest.getChromosome());</span>
<span class="fc bfc" id="L879" title="All 2 branches covered.">        } else if (Utils.eq(m_population[i].getObjective(), b)) {</span>
          // see if it contains fewer features
<span class="fc" id="L881">          count = countFeatures(m_population[i].getChromosome());</span>
<span class="fc bfc" id="L882" title="All 2 branches covered.">          if (count &lt; oldcount) {</span>
<span class="fc" id="L883">            b = m_population[i].getObjective();</span>
<span class="fc" id="L884">            localbest = m_population[i];</span>
<span class="fc" id="L885">            oldcount = count;</span>
          }
        }
      }
    } else {
      // look for the smallest subset
<span class="fc bfc" id="L891" title="All 2 branches covered.">      for (i=0;i&lt;m_popSize;i++) {</span>
<span class="fc" id="L892">        temp = m_population[i].getChromosome();</span>
<span class="fc" id="L893">        count = countFeatures(temp);;</span>

<span class="fc bfc" id="L895" title="All 2 branches covered.">        if (count &lt; lowestCount) {</span>
<span class="fc" id="L896">          lowestCount = count;</span>
<span class="fc" id="L897">          localbest = m_population[i];</span>
<span class="fc" id="L898">          b = localbest.getObjective();</span>
        }
      }
<span class="fc" id="L901">      converged = true;</span>
    }

    // count the number of features in localbest
<span class="fc" id="L905">    count = 0;</span>
<span class="fc" id="L906">    temp = localbest.getChromosome();</span>
<span class="fc" id="L907">    count = countFeatures(temp);</span>

    // compare to the best found so far
<span class="fc bfc" id="L910" title="All 2 branches covered.">    if (m_best == null) {</span>
<span class="fc" id="L911">      m_best = (GABitSet)localbest.clone();</span>
<span class="fc" id="L912">      m_bestFeatureCount = count;</span>
<span class="fc bfc" id="L913" title="All 2 branches covered.">    } else if (b &gt; m_best.getObjective()) {</span>
<span class="fc" id="L914">      m_best = (GABitSet)localbest.clone();</span>
<span class="fc" id="L915">      m_bestFeatureCount = count;</span>
<span class="pc bpc" id="L916" title="1 of 2 branches missed.">    } else if (Utils.eq(m_best.getObjective(), b)) {</span>
      // see if the localbest has fewer features than the best so far
<span class="fc bfc" id="L918" title="All 2 branches covered.">      if (count &lt; m_bestFeatureCount) {</span>
<span class="fc" id="L919">        m_best = (GABitSet)localbest.clone();</span>
<span class="fc" id="L920">        m_bestFeatureCount = count;</span>
      }
    }
<span class="fc" id="L923">    return converged;</span>
  }

  /**
   * counts the number of features in a subset
   * @param featureSet the feature set for which to count the features
   * @return the number of features in the subset
   */
  private int countFeatures(BitSet featureSet) {
<span class="fc" id="L932">    int count = 0;</span>
<span class="fc bfc" id="L933" title="All 2 branches covered.">    for (int i=0;i&lt;m_numAttribs;i++) {</span>
<span class="fc bfc" id="L934" title="All 2 branches covered.">      if (featureSet.get(i)) {</span>
<span class="fc" id="L935">        count++;</span>
      }
    }
<span class="fc" id="L938">    return count;</span>
  }

  /**
   * performs a single generation---selection, crossover, and mutation
   * @throws Exception if an error occurs
   */
  private void generation () throws Exception {
<span class="fc" id="L946">    int i,j=0;</span>
<span class="fc" id="L947">    double best_fit = -Double.MAX_VALUE;</span>
<span class="fc" id="L948">    int old_count = 0;</span>
    int count;
<span class="fc" id="L950">    GABitSet [] newPop = new GABitSet [m_popSize];</span>
    int parent1,parent2;

    /** first ensure that the population best is propogated into the new
        generation */
<span class="fc bfc" id="L955" title="All 2 branches covered.">    for (i=0;i&lt;m_popSize;i++) {</span>
<span class="fc bfc" id="L956" title="All 2 branches covered.">      if (m_population[i].getFitness() &gt; best_fit) {</span>
<span class="fc" id="L957">        j = i;</span>
<span class="fc" id="L958">        best_fit = m_population[i].getFitness();</span>
<span class="fc" id="L959">        old_count = countFeatures(m_population[i].getChromosome());</span>
<span class="fc bfc" id="L960" title="All 2 branches covered.">      } else if (Utils.eq(m_population[i].getFitness(), best_fit)) {</span>
<span class="fc" id="L961">        count = countFeatures(m_population[i].getChromosome());</span>
<span class="fc bfc" id="L962" title="All 2 branches covered.">        if (count &lt; old_count) {</span>
<span class="fc" id="L963">          j = i;</span>
<span class="fc" id="L964">          best_fit = m_population[i].getFitness();</span>
<span class="fc" id="L965">          old_count = count;</span>
        }
      }
    }
<span class="fc" id="L969">    newPop[0] = (GABitSet)(m_population[j].clone());</span>
<span class="fc" id="L970">    newPop[1] = newPop[0];</span>

<span class="fc bfc" id="L972" title="All 2 branches covered.">    for (j=2;j&lt;m_popSize;j+=2) {</span>
<span class="fc" id="L973">      parent1 = select();</span>
<span class="fc" id="L974">      parent2 = select();</span>
<span class="fc" id="L975">      newPop[j] = (GABitSet)(m_population[parent1].clone());</span>
<span class="fc" id="L976">      newPop[j+1] = (GABitSet)(m_population[parent2].clone());</span>
      // if parents are equal mutate one bit
<span class="fc bfc" id="L978" title="All 2 branches covered.">      if (parent1 == parent2) {</span>
        int r;
<span class="pc bpc" id="L980" title="1 of 2 branches missed.">        if (m_hasClass) {</span>
<span class="fc bfc" id="L981" title="All 2 branches covered.">          while ((r = m_random.nextInt(m_numAttribs)) == m_classIndex);</span>
        }
        else {
<span class="nc" id="L984">          r = m_random.nextInt(m_numAttribs);</span>
        }
        
<span class="fc bfc" id="L987" title="All 2 branches covered.">        if (newPop[j].get(r)) {</span>
<span class="fc" id="L988">          newPop[j].clear(r);</span>
        }
        else {
<span class="fc" id="L991">          newPop[j].set(r);</span>
        }
<span class="fc" id="L993">      } else {</span>
        // crossover
<span class="fc" id="L995">        double r = m_random.nextDouble();</span>
<span class="fc bfc" id="L996" title="All 2 branches covered.">        if (m_numAttribs &gt;= 3) {</span>
<span class="fc bfc" id="L997" title="All 2 branches covered.">          if (r &lt; m_pCrossover) {</span>
            // cross point
<span class="fc" id="L999">            int cp = Math.abs(m_random.nextInt());</span>
            
<span class="fc" id="L1001">            cp %= (m_numAttribs-2);</span>
<span class="fc" id="L1002">            cp ++;</span>
            
<span class="fc bfc" id="L1004" title="All 2 branches covered.">            for (i=0;i&lt;cp;i++) {</span>
<span class="fc bfc" id="L1005" title="All 2 branches covered.">              if (m_population[parent1].get(i)) {</span>
<span class="fc" id="L1006">                newPop[j+1].set(i);</span>
              }
              else {
<span class="fc" id="L1009">                newPop[j+1].clear(i);</span>
              }
<span class="fc bfc" id="L1011" title="All 2 branches covered.">              if (m_population[parent2].get(i)) {</span>
<span class="fc" id="L1012">                newPop[j].set(i);</span>
              }
              else {
<span class="fc" id="L1015">                newPop[j].clear(i);</span>
              }
            }
          }
        }

        // mutate
<span class="fc bfc" id="L1022" title="All 2 branches covered.">        for (int k=0;k&lt;2;k++) {</span>
<span class="fc bfc" id="L1023" title="All 2 branches covered.">          for (i=0;i&lt;m_numAttribs;i++) {</span>
<span class="fc" id="L1024">            r = m_random.nextDouble();</span>
<span class="fc bfc" id="L1025" title="All 2 branches covered.">            if (r &lt; m_pMutation) {</span>
<span class="pc bpc" id="L1026" title="1 of 4 branches missed.">              if (m_hasClass &amp;&amp; (i == m_classIndex)) {</span>
                // ignore class attribute
              }
              else {
<span class="fc bfc" id="L1030" title="All 2 branches covered.">                if (newPop[j+k].get(i)) {</span>
<span class="fc" id="L1031">                  newPop[j+k].clear(i);</span>
                }
                else {
<span class="fc" id="L1034">                  newPop[j+k].set(i);</span>
                }
              }
            }
          }
        }
                  
      }
    }

<span class="fc" id="L1044">    m_population = newPop;</span>
<span class="fc" id="L1045">  }</span>

  /**
   * selects a population member to be considered for crossover
   * @return the index of the selected population member
   */
  private int select() {
    int i;
    double r,partsum;

<span class="fc" id="L1055">    partsum = 0;</span>
<span class="fc" id="L1056">    r = m_random.nextDouble() * m_sumFitness;</span>
<span class="pc bpc" id="L1057" title="1 of 2 branches missed.">    for (i=0;i&lt;m_popSize;i++) {</span>
<span class="fc" id="L1058">      partsum += m_population[i].getFitness();</span>
<span class="fc bfc" id="L1059" title="All 4 branches covered.">      if (partsum &gt;= r || (i == m_popSize - 1)) {</span>
<span class="fc" id="L1060">        break;</span>
      }
    }
    
    // if none was found, take first
<span class="pc bpc" id="L1065" title="1 of 2 branches missed.">    if (i == m_popSize)</span>
<span class="nc" id="L1066">      i = 0;</span>
    
<span class="fc" id="L1068">    return i;</span>
  }

  /**
   * evaluates an entire population. Population members are looked up in
   * a hash table and if they are not found then they are evaluated using
   * ASEvaluator.
   * @param ASEvaluator the subset evaluator to use for evaluating population
   * members
   * @throws Exception if something goes wrong during evaluation
   */
  private void evaluatePopulation (SubsetEvaluator ASEvaluator)
    throws Exception {
    int i;
    double merit;

<span class="fc bfc" id="L1084" title="All 2 branches covered.">    for (i=0;i&lt;m_popSize;i++) {</span>
      // if its not in the lookup table then evaluate and insert
<span class="fc bfc" id="L1086" title="All 2 branches covered.">      if (m_lookupTable.containsKey(m_population[i]</span>
<span class="fc" id="L1087">                                    .getChromosome()) == false) {</span>
<span class="fc" id="L1088">        merit = ASEvaluator.evaluateSubset(m_population[i].getChromosome());</span>
<span class="fc" id="L1089">        m_population[i].setObjective(merit);</span>
<span class="fc" id="L1090">        m_lookupTable.put(m_population[i].getChromosome(),m_population[i]);</span>
      } else {
<span class="fc" id="L1092">        GABitSet temp = (GABitSet)m_lookupTable.</span>
<span class="fc" id="L1093">          get(m_population[i].getChromosome());</span>
<span class="fc" id="L1094">        m_population[i].setObjective(temp.getObjective());</span>
      }
    }
<span class="fc" id="L1097">  }</span>

  /**
   * creates random population members for the initial population. Also
   * sets the first population member to be a start set (if any) 
   * provided by the user
   * @throws Exception if the population can't be created
   */
  private void initPopulation () throws Exception {
    int i,j,bit;
    int num_bits;
    boolean ok;
<span class="fc" id="L1109">    int start = 0;</span>

    // add the start set as the first population member (if specified)
<span class="pc bpc" id="L1112" title="1 of 2 branches missed.">    if (m_starting != null) {</span>
<span class="nc" id="L1113">      m_population[0] = new GABitSet();</span>
<span class="nc bnc" id="L1114" title="All 2 branches missed.">      for (i=0;i&lt;m_starting.length;i++) {</span>
<span class="nc bnc" id="L1115" title="All 2 branches missed.">        if ((m_starting[i]) != m_classIndex) {</span>
<span class="nc" id="L1116">          m_population[0].set(m_starting[i]);</span>
        }
      }
<span class="nc" id="L1119">      start = 1;</span>
    }

<span class="fc bfc" id="L1122" title="All 2 branches covered.">    for (i=start;i&lt;m_popSize;i++) {</span>
<span class="fc" id="L1123">      m_population[i] = new GABitSet();</span>
      
<span class="fc" id="L1125">      num_bits = m_random.nextInt();</span>
<span class="fc" id="L1126">      num_bits = num_bits % m_numAttribs-1;</span>
<span class="fc bfc" id="L1127" title="All 2 branches covered.">      if (num_bits &lt; 0) {</span>
<span class="fc" id="L1128">        num_bits *= -1;</span>
      }
<span class="fc bfc" id="L1130" title="All 2 branches covered.">      if (num_bits == 0) {</span>
<span class="fc" id="L1131">        num_bits = 1;</span>
      }

<span class="fc bfc" id="L1134" title="All 2 branches covered.">      for (j=0;j&lt;num_bits;j++) {</span>
<span class="fc" id="L1135">        ok = false;</span>
        do {
<span class="fc" id="L1137">          bit = m_random.nextInt();</span>
<span class="fc bfc" id="L1138" title="All 2 branches covered.">          if (bit &lt; 0) {</span>
<span class="fc" id="L1139">            bit *= -1;</span>
          }
<span class="fc" id="L1141">          bit = bit % m_numAttribs;</span>
<span class="pc bpc" id="L1142" title="1 of 2 branches missed.">          if (m_hasClass) {</span>
<span class="fc bfc" id="L1143" title="All 2 branches covered.">            if (bit != m_classIndex) {</span>
<span class="fc" id="L1144">              ok = true;</span>
            }
          }
          else {
<span class="nc" id="L1148">            ok = true;</span>
          }
<span class="fc bfc" id="L1150" title="All 2 branches covered.">        } while (!ok);</span>
        
<span class="pc bpc" id="L1152" title="1 of 2 branches missed.">        if (bit &gt; m_numAttribs) {</span>
<span class="nc" id="L1153">          throw new Exception(&quot;Problem in population init&quot;);</span>
        }
<span class="fc" id="L1155">        m_population[i].set(bit);</span>
      }
    }
<span class="fc" id="L1158">  }</span>

  /**
   * calculates summary statistics for the current population
   */
  private void populationStatistics() {
    int i;
    
<span class="fc" id="L1166">    m_sumFitness = m_minFitness = m_maxFitness = </span>
<span class="fc" id="L1167">      m_population[0].getObjective();</span>

<span class="fc bfc" id="L1169" title="All 2 branches covered.">    for (i=1;i&lt;m_popSize;i++) {</span>
<span class="fc" id="L1170">      m_sumFitness += m_population[i].getObjective();</span>
<span class="fc bfc" id="L1171" title="All 2 branches covered.">      if (m_population[i].getObjective() &gt; m_maxFitness) {</span>
<span class="fc" id="L1172">        m_maxFitness = m_population[i].getObjective();</span>
      }
<span class="fc bfc" id="L1174" title="All 2 branches covered.">      else if (m_population[i].getObjective() &lt; m_minFitness) {</span>
<span class="fc" id="L1175">        m_minFitness = m_population[i].getObjective();</span>
      }
    }
<span class="fc" id="L1178">    m_avgFitness = (m_sumFitness / m_popSize);</span>
<span class="fc" id="L1179">  }</span>

  /**
   * scales the raw (objective) merit of the population members
   */
  private void scalePopulation() {
    int j;
<span class="fc" id="L1186">    double a = 0;</span>
<span class="fc" id="L1187">    double b = 0;</span>
<span class="fc" id="L1188">    double fmultiple = 2.0;</span>
    double delta;
    
    // prescale
<span class="fc bfc" id="L1192" title="All 2 branches covered.">    if (m_minFitness &gt; ((fmultiple * m_avgFitness - m_maxFitness) / </span>
                        (fmultiple - 1.0))) {
<span class="fc" id="L1194">      delta = m_maxFitness - m_avgFitness;</span>
<span class="fc" id="L1195">      a = ((fmultiple - 1.0) * m_avgFitness / delta);</span>
<span class="fc" id="L1196">      b = m_avgFitness * (m_maxFitness - fmultiple * m_avgFitness) / delta;</span>
    }
    else {
<span class="fc" id="L1199">      delta = m_avgFitness - m_minFitness;</span>
<span class="fc" id="L1200">      a = m_avgFitness / delta;</span>
<span class="fc" id="L1201">      b = -m_minFitness * m_avgFitness / delta;</span>
    }
      
    // scalepop
<span class="fc" id="L1205">    m_sumFitness = 0;</span>
<span class="fc bfc" id="L1206" title="All 2 branches covered.">    for (j=0;j&lt;m_popSize;j++) {</span>
<span class="pc bpc" id="L1207" title="3 of 8 branches missed.">      if (a == Double.POSITIVE_INFINITY || a == Double.NEGATIVE_INFINITY ||</span>
          b == Double.POSITIVE_INFINITY || b == Double.NEGATIVE_INFINITY) {
<span class="fc" id="L1209">        m_population[j].setFitness(m_population[j].getObjective());</span>
      } else {
<span class="fc" id="L1211">        m_population[j].</span>
<span class="fc" id="L1212">          setFitness(Math.abs((a * m_population[j].getObjective() + b)));</span>
      }
<span class="fc" id="L1214">      m_sumFitness += m_population[j].getFitness();</span>
    }
<span class="fc" id="L1216">  }</span>
  
  /**
   * generates a report on the current population
   * @return a report as a String
   */
  private String populationReport (int genNum) {
    int i;
<span class="fc" id="L1224">    StringBuffer temp = new StringBuffer();</span>

<span class="fc bfc" id="L1226" title="All 2 branches covered.">    if (genNum == 0) {</span>
<span class="fc" id="L1227">      temp.append(&quot;\nInitial population\n&quot;);</span>
    }
    else {
<span class="fc" id="L1230">      temp.append(&quot;\nGeneration: &quot;+genNum+&quot;\n&quot;);</span>
    }
<span class="fc" id="L1232">    temp.append(&quot;merit   \tscaled  \tsubset\n&quot;);</span>
    
<span class="fc bfc" id="L1234" title="All 2 branches covered.">    for (i=0;i&lt;m_popSize;i++) {</span>
<span class="fc" id="L1235">      temp.append(Utils.doubleToString(Math.</span>
<span class="fc" id="L1236">                                       abs(m_population[i].getObjective()),</span>
                                       8,5)
                  +&quot;\t&quot;
<span class="fc" id="L1239">                  +Utils.doubleToString(m_population[i].getFitness(),</span>
                                        8,5)
                  +&quot;\t&quot;);

<span class="fc" id="L1243">      temp.append(printPopMember(m_population[i].getChromosome())+&quot;\n&quot;);</span>
    }
<span class="fc" id="L1245">    return temp.toString();</span>
  }

  /**
   * prints a population member as a series of attribute numbers
   * @param temp the chromosome of a population member
   * @return a population member as a String of attribute numbers
   */
  private String printPopMember(BitSet temp) {
<span class="fc" id="L1254">    StringBuffer text = new StringBuffer();</span>

<span class="fc bfc" id="L1256" title="All 2 branches covered.">    for (int j=0;j&lt;m_numAttribs;j++) {</span>
<span class="fc bfc" id="L1257" title="All 2 branches covered.">      if (temp.get(j)) {</span>
<span class="fc" id="L1258">        text.append((j+1)+&quot; &quot;);</span>
      }
    }
<span class="fc" id="L1261">    return text.toString();</span>
  }

  /**
   * prints a population member's chromosome
   * @param temp the chromosome of a population member
   * @return a population member's chromosome as a String
   */
  private String printPopChrom(BitSet temp) {
<span class="nc" id="L1270">    StringBuffer text = new StringBuffer();</span>

<span class="nc bnc" id="L1272" title="All 2 branches missed.">    for (int j=0;j&lt;m_numAttribs;j++) {</span>
<span class="nc bnc" id="L1273" title="All 2 branches missed.">      if (temp.get(j)) {</span>
<span class="nc" id="L1274">        text.append(&quot;1&quot;);</span>
      } else {
<span class="nc" id="L1276">        text.append(&quot;0&quot;);</span>
      }
    }
<span class="nc" id="L1279">    return text.toString();</span>
  }

  /**
   * reset to default values for options
   */
  private void resetOptions () {
<span class="fc" id="L1286">    m_population = null;</span>
<span class="fc" id="L1287">    m_popSize = 20;</span>
<span class="fc" id="L1288">    m_lookupTableSize = 1001;</span>
<span class="fc" id="L1289">    m_pCrossover = 0.6;</span>
<span class="fc" id="L1290">    m_pMutation = 0.033;</span>
<span class="fc" id="L1291">    m_maxGenerations = 20;</span>
<span class="fc" id="L1292">    m_reportFrequency = m_maxGenerations;</span>
<span class="fc" id="L1293">    m_starting = null;</span>
<span class="fc" id="L1294">    m_startRange = new Range();</span>
<span class="fc" id="L1295">    m_seed = 1;</span>
<span class="fc" id="L1296">  }</span>
  
  /**
   * Returns the revision string.
   * 
   * @return		the revision
   */
  public String getRevision() {
<span class="nc" id="L1304">    return RevisionUtils.extract(&quot;$Revision: 6759 $&quot;);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>